"use strict";(self.webpackChunkpantsbuild_org=self.webpackChunkpantsbuild_org||[]).push([["513943"],{173849(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>s,toc:()=>l});var s=t(906844),i=t(886070),r=t(848193);let d={title:"Targets and BUILD files",sidebar_position:1},o,a={},l=[{value:"BUILD files",id:"build-files",level:2},{value:"Target addresses",id:"target-addresses",level:2},{value:"Sources",id:"sources",level:2},{value:"Dependencies and dependency inference",id:"dependencies-and-dependency-inference",level:2},{value:"The build graph and dependency cycles",id:"the-build-graph-and-dependency-cycles",level:2},{value:"Target granularity for first-party code",id:"target-granularity-for-first-party-code",level:2}];function c(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Metadata for your code."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"Most goals require metadata about your code. For example, to run a test, you need to know about all the transitive dependencies of that test. You may also want to set a timeout on that test."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Targets"})," are a set of metadata describing your code."]}),"\n",(0,i.jsxs)(n.p,{children:["Some targets like ",(0,i.jsx)(n.code,{children:"files"})," and ",(0,i.jsx)(n.code,{children:"python_library"})," describe your first-party code, some like ",(0,i.jsx)(n.code,{children:"python_requirement_library"})," describe your third-party requirements, and others like ",(0,i.jsx)(n.code,{children:"pex_binary"})," and ",(0,i.jsx)(n.code,{children:"archive"})," describe artifacts you'd like Pants to build."]}),"\n",(0,i.jsx)(n.h2,{id:"build-files",children:"BUILD files"}),"\n",(0,i.jsxs)(n.p,{children:["Targets are defined in files with the name ",(0,i.jsx)(n.code,{children:"BUILD"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, this ",(0,i.jsx)(n.code,{children:"BUILD"})," file defines two targets:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="helloworld/greet/BUILD"',children:'python_tests(\n    name="tests",\n    sources=["test_*.py"],\n    timeout=120,\n)\n\npex_binary(\n    name="bin",\n    entry_point="app.py",\n    zip_safe=False,\n)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Each target type has different ",(0,i.jsx)(n.em,{children:"fields"}),", or individual metadata values. Run ",(0,i.jsx)(n.code,{children:"./pants help $target"})," to see which fields a particular target type has, e.g. ",(0,i.jsx)(n.code,{children:"./pants help files"}),". Most fields are optional and use sensible defaults."]}),"\n",(0,i.jsxs)(n.p,{children:["All target types have a ",(0,i.jsx)(n.code,{children:"name"})," field, which is used to identify the target. Target names must be unique within a directory. If you leave off the ",(0,i.jsx)(n.code,{children:"name"})," field, it will default to the BUILD file's directory name."]}),"\n",(0,i.jsxs)(n.p,{children:["Some target types are always available, but most require first registering backends. For example, the ",(0,i.jsx)(n.code,{children:"python_tests"})," and ",(0,i.jsx)(n.code,{children:"pex_binary"})," target types are provided by the ",(0,i.jsx)(n.code,{children:"pants.backend.python"})," backend."]}),"\n",(0,i.jsx)(n.h2,{id:"target-addresses",children:"Target addresses"}),"\n",(0,i.jsxs)(n.p,{children:["A target is identified by its address. A target address has the form ",(0,i.jsx)(n.code,{children:"path/to/directory:name"}),". For example, the targets in the example above have the addresses ",(0,i.jsx)(n.code,{children:"helloworld/greet:tests"})," and ",(0,i.jsx)(n.code,{children:"helloworld/greet:bin"}),", respectively."]}),"\n",(0,i.jsxs)(n.p,{children:["Addresses can be used as command-line arguments, such as ",(0,i.jsx)(n.code,{children:"./pants fmt path/to:target"}),", which will format all files that are in the ",(0,i.jsx)(n.code,{children:"sources"})," field of ",(0,i.jsx)(n.code,{children:":target"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Addresses are also used in the ",(0,i.jsx)(n.code,{children:"dependencies"})," field to depend on other targets, as explained below."]}),"\n",(0,i.jsx)(n.p,{children:"Addresses are globally unique, which is guaranteed by the fact that target names must be unique within a directory."}),"\n",(0,i.jsx)(n.admonition,{title:"Address abbreviation",type:"note",children:(0,i.jsxs)(n.p,{children:["If the target name is the same as the name of the directory containing it, then you can omit the target name. For example, ",(0,i.jsx)(n.code,{children:"helloworld/greet"})," is an abbreviated form of ",(0,i.jsx)(n.code,{children:"helloworld/greet:greet"}),"."]})}),"\n",(0,i.jsxs)(n.admonition,{title:'Addresses at at the "build root"',type:"note",children:[(0,i.jsxs)(n.p,{children:["You may sometimes have a ",(0,i.jsx)(n.code,{children:"BUILD"})," file at your build root, i.e. the top-level of your project. These addresses are prefixed with ",(0,i.jsx)(n.code,{children:"//"})," for clarity."]}),(0,i.jsxs)(n.p,{children:["For example, ",(0,i.jsx)(n.code,{children:"//:my_tgt"})," refers to a a target defined in ",(0,i.jsx)(n.code,{children:"<build root>/BUILD"})," with the field ",(0,i.jsx)(n.code,{children:'name="my_tgt"'}),"."]})]}),"\n",(0,i.jsx)(n.h2,{id:"sources",children:"Sources"}),"\n",(0,i.jsxs)(n.p,{children:["Targets for first-party code have a ",(0,i.jsx)(n.code,{children:"sources"})," field, which determines which source files belong to the target."]}),"\n",(0,i.jsxs)(n.p,{children:["The value of the ",(0,i.jsx)(n.code,{children:"sources"})," field is a list of names and/or glob patterns, relative to the BUILD file's directory. Sources must be in or below this directory, i.e., patterns containing ",(0,i.jsx)(n.code,{children:"../"})," are not allowed."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"!"})," prefix excludes matching files that would otherwise be included. For example, ",(0,i.jsx)(n.code,{children:"['*.py', '!exclude_*.py']"})," will include ",(0,i.jsx)(n.code,{children:"foo.py"})," but not ",(0,i.jsx)(n.code,{children:"exclude_bar.py"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.code,{children:"**"})," for a recursive glob, e.g. ",(0,i.jsx)(n.code,{children:"sources=['**/*.py']"}),"."]}),"\n",(0,i.jsxs)(n.admonition,{type:"caution",children:[(0,i.jsxs)(n.mdxAdmonitionTitle,{children:["Overlapping ",(0,i.jsx)(n.code,{children:"sources"})," fields can cause confusion"]}),(0,i.jsxs)(n.p,{children:["It's valid to include the same file in the ",(0,i.jsx)(n.code,{children:"sources"})," for multiple targets. When would you do this? Sometimes you may have conflicting metadata for the same source file, such as toggling between a GPU vs. CPU version of a dependency:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'python_library(\n    name="lib_cpu",\n    sources=["lib.py"],\n    dependencies=["3rdparty:tensorflow"],\n)\n\npython_library(\n    name="lib_gpu",\n    sources=["lib.py"],\n    dependencies=["3rdparty:tensorflow-gpu"],\n)\n'})}),(0,i.jsxs)(n.p,{children:["However, including the same file in the ",(0,i.jsx)(n.code,{children:"sources"})," for multiple targets can result in two confusing behaviors:"]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Pants will no longer be able to infer dependencies on this file because it cannot disambiguate which of the targets you want to use. You must use explicit dependencies instead."}),"\n",(0,i.jsxs)(n.li,{children:["File arguments will run over all owning targets, e.g. ",(0,i.jsx)(n.code,{children:"./pants test path/to/test.ext"})," would run both test targets as two separate subprocesses, even though you might only expect a single subprocess."]}),"\n"]}),(0,i.jsxs)(n.p,{children:["You can run ",(0,i.jsx)(n.code,{children:"./pants list path/to/file.ext"}),' to see all "owning" targets to check if >1 target has the file in its ',(0,i.jsx)(n.code,{children:"sources"})," field."]})]}),"\n",(0,i.jsx)(n.h2,{id:"dependencies-and-dependency-inference",children:"Dependencies and dependency inference"}),"\n",(0,i.jsxs)(n.p,{children:["Almost all targets have a ",(0,i.jsx)(n.code,{children:"dependencies"})," field, which is used to determine which of your first-party code and third-party requirements to use."]}),"\n",(0,i.jsxs)(n.p,{children:["Normally, you can leave off the ",(0,i.jsx)(n.code,{children:"dependencies"})," field, thanks to ",(0,i.jsx)(n.em,{children:"dependency inference"}),". Pants will read your import statements and map those imports back to your first-party code and your third-party requirements. You can run ",(0,i.jsx)(n.code,{children:"./pants dependencies path/to/file.ext"})," or ",(0,i.jsx)(n.code,{children:"./pants dependencies path/to:target"})," to see what dependencies Pants infers."]}),"\n",(0,i.jsxs)(n.p,{children:["However, dependency inference cannot infer everything. For example, dependency inference does not know how to infer dependencies on ",(0,i.jsx)(n.code,{children:"resources()"})," and ",(0,i.jsx)(n.code,{children:"files()"})," targets, so you will need to sometimes explicitly add to the ",(0,i.jsx)(n.code,{children:"dependencies"})," field."]}),"\n",(0,i.jsx)(n.p,{children:"To add a new explicit dependency, add the address to the target:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="helloworld/greet/BUILD"',children:'python_library(\n    dependencies=[\n        "3rdparty/python:ansicolors",\n        "helloworld/util",  # shorthand for `helloworld/util:util`\n        "helloworld/util:json_files,\n    ],\n)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Adding a dependency on a target describing first-party code, e.g. a ",(0,i.jsx)(n.code,{children:"python_library"})," or ",(0,i.jsx)(n.code,{children:"files"})," target, will add all of the files from that target's ",(0,i.jsx)(n.code,{children:"sources"}),' field. See the below tooltip "Explicit file addresses" for how to instead use more granular dependencies, which is what dependency inference uses.']}),"\n",(0,i.jsxs)(n.p,{children:["You only need to declare direct dependencies; there is no need to include the dependencies of your dependencies. Pants will pull in those ",(0,i.jsx)(n.em,{children:"transitive dependencies"})," for you."]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.mdxAdmonitionTitle,{children:["Ignore dependencies with ",(0,i.jsx)(n.code,{children:"!"})," and ",(0,i.jsx)(n.code,{children:"!!"})]}),(0,i.jsxs)(n.p,{children:["If you don't like that Pants inferred a certain dependency, you can tell Pants to ignore it with ",(0,i.jsx)(n.code,{children:"!"}),". Run ",(0,i.jsx)(n.code,{children:"./pants dependencies"})," to find the address for the problematic dependency, then copy it into the ",(0,i.jsx)(n.code,{children:"dependencies"})," field with a ",(0,i.jsx)(n.code,{children:"!"})," prefix."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'python_library(\n    dependencies=["!3rdparty/python:numpy"],\n)\n'})}),(0,i.jsxs)(n.p,{children:["You can use the prefix ",(0,i.jsx)(n.code,{children:"!!"})," to ",(0,i.jsx)(n.em,{children:"transitively"})," exclude a dependency, meaning that even if a target's dependencies include the bad dependency, no matter what, the final result will not include the value."]}),(0,i.jsxs)(n.p,{children:["Transitive excludes can only be used in target types that conventionally are not dependend upon by other targets, such as ",(0,i.jsx)(n.code,{children:"pex_binary"})," and ",(0,i.jsx)(n.code,{children:"python_tests"}),". This is meant to limit confusion, as using ",(0,i.jsx)(n.code,{children:"!!"})," in something like a ",(0,i.jsx)(n.code,{children:"python_library"})," could result in surprising behavior for everything that depends on it. If you use ",(0,i.jsx)(n.code,{children:"!!"})," when not allowed to, Pants will print a helpful error message saying where you can use it."]})]}),"\n",(0,i.jsxs)(n.admonition,{title:'Explicit "file addresses"',type:"note",children:[(0,i.jsxs)(n.p,{children:["When you declare an explicit dependency on a target for first-party code, like ",(0,i.jsx)(n.code,{children:"helloworld/util:json_files"}),", you end up depending on every file in the ",(0,i.jsx)(n.code,{children:"sources"})," field of ",(0,i.jsx)(n.code,{children:":json_files"}),", even if you only use some of the files. Often, this is what you meant."]}),(0,i.jsx)(n.p,{children:'However, sometimes you want to be more granular, which results in finer-grained invalidation for caching. To do this, you can use a "file address", which tells Pants to only depend on a specific file from a certain target.'}),(0,i.jsx)(n.p,{children:"Pants's dependency inference automatically uses file addresses already, so you only need to use explicit file addresses when Pants cannot infer the dependency and you want more granular dependencies than normal target addresses."}),(0,i.jsxs)(n.p,{children:["To add an explicit file address, add the file path, followed by ",(0,i.jsx)(n.code,{children:":target_name"}),". For example, ",(0,i.jsx)(n.code,{children:"helloworld/util/f1.json:json_resources"}),". If the target name is the default name, you can leave off the ",(0,i.jsx)(n.code,{children:":target_name"})," part. If the file is in the same directory or a subdirectory, you can use a relative file path like ",(0,i.jsx)(n.code,{children:"./f1.json:json_resources"}),"."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'python_library(\n    dependencies=[\n        "helloworld/util/f1.json:json_resources",\n        "./f2.json:json_resources",  # Shorthand for "helloworld/util/f2.json:json_resources\n        "helloworld/app.py",  # Shorthand for "helloworld/app.py:helloworld"\n    ],\n)\n'})}),(0,i.jsx)(n.p,{children:"What if the file's target's BUILD file is in a different directory than that file? For example, consider this target definition:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'resources(\n  name="json_resources",\n  sources=["**/*.json"],\n)\n'})}),(0,i.jsxs)(n.p,{children:["If the file is in a subdirectory from the original target definition, use ",(0,i.jsx)(n.code,{children:"../"})," in the target_name section, e.g. ",(0,i.jsx)(n.code,{children:"helloworld/util/f1.json:../json_resources"}),"."]})]}),"\n",(0,i.jsx)(n.h2,{id:"the-build-graph-and-dependency-cycles",children:"The build graph and dependency cycles"}),"\n",(0,i.jsxs)(n.p,{children:["The set of targets in a repo form the ",(0,i.jsx)(n.em,{children:"build graph"}),". The vertices in this graph are the targets, and the (directed) edges are the dependencies."]}),"\n",(0,i.jsx)(n.p,{children:"The build graph must not contain directed cycles, i.e., it must form a DAG (a Directed Acyclic Graph). If you do have a cycle, Pants will print an error message explaining what caused the cycle and giving suggestions for how to fix it."}),"\n",(0,i.jsx)(n.h2,{id:"target-granularity-for-first-party-code",children:"Target granularity for first-party code"}),"\n",(0,i.jsxs)(n.p,{children:["A first-party target's ",(0,i.jsx)(n.code,{children:"sources"})," field can be as fine-grained as a single file or as course-grained as an entire tree of files."]}),"\n",(0,i.jsxs)(n.p,{children:["If you use dependency inference and explicit file addresses in the ",(0,i.jsx)(n.code,{children:"dependencies"})," field, then target granularity has no implications for your caching and invalidation. You can, in theory, define one ",(0,i.jsx)(n.code,{children:"python_library"})," target for your entire project, for example. (However, this usually doesn't scale well as your codebase evolves.)"]}),"\n",(0,i.jsxs)(n.p,{children:["In contrast, if you use normal target addresses in the ",(0,i.jsx)(n.code,{children:"dependencies"})," field, then target granularity does have implications for caching and invalidation. Every time you add a new dependency to a target, you end up depending on every file from the ",(0,i.jsx)(n.code,{children:"sources"})," field of the dependency, even if some of them are not used. So, more granular targets will result in better caching and invalidation."]}),"\n",(0,i.jsxs)(n.p,{children:["In practice, we've found that having one library and/or one test target per-directory tends to work well. The default ",(0,i.jsx)(n.code,{children:"sources"})," values for various target types reflect this."]}),"\n",(0,i.jsx)(n.p,{children:"For example, for a Python project with tests colocated with source code, we recommend defaulting to a BUILD file like this in every directory:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'python_library()\n\npython_tests(name="tests")\n'})}),"\n",(0,i.jsx)(n.admonition,{title:"Tips on setting up initial BUILD files",type:"note",children:(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"/2.2/docs/using-pants/adopting-pants-in-existing-repos",children:"Adopting Pants in an Existing Repo"})," for tips on setting up Pants, including where to add BUILD files."]})})]})}function h(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},848193(e,n,t){t.d(n,{R:()=>d,x:()=>o});var s=t(830758);let i={},r=s.createContext(i);function d(e){let n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),s.createElement(r.Provider,{value:n},e.children)}},906844(e){e.exports=JSON.parse('{"id":"docs/using-pants/concepts/targets-and-build-files","title":"Targets and BUILD files","description":"Metadata for your code.","source":"@site/versioned_docs/version-2.2/docs/using-pants/concepts/targets-and-build-files.mdx","sourceDirName":"docs/using-pants/concepts","slug":"/docs/using-pants/concepts/targets-and-build-files","permalink":"/2.2/docs/using-pants/concepts/targets-and-build-files","draft":false,"unlisted":false,"editUrl":"https://github.com/pantsbuild/pants/edit/main/docs/docs/using-pants/concepts/targets-and-build-files.mdx","tags":[],"version":"2.2","sidebarPosition":1,"frontMatter":{"title":"Targets and BUILD files","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Goals","permalink":"/2.2/docs/using-pants/concepts/goals"},"next":{"title":"Options","permalink":"/2.2/docs/using-pants/concepts/options"}}')}}]);