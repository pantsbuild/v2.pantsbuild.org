"use strict";(self.webpackChunkpantsbuild_org=self.webpackChunkpantsbuild_org||[]).push([["751851"],{321298(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});var t=s(27085),i=s(886070),r=s(848193);let o={title:"Installing tools",sidebar_position:5},a,l={},c=[{value:"<code>BinaryPaths</code>: Find already installed binaries",id:"binarypaths-find-already-installed-binaries",level:2},{value:"<code>ExternalTool</code>: Install pre-compiled binaries",id:"externaltool-install-pre-compiled-binaries",level:2},{value:"<code>Pex</code>: Install binaries through pip",id:"pex-install-binaries-through-pip",level:2}];function d(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",hr:"hr",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Various methods for Pants to access the tools your plugin needs."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h2,{id:"binarypaths-find-already-installed-binaries",children:[(0,i.jsx)(n.code,{children:"BinaryPaths"}),": Find already installed binaries"]}),"\n",(0,i.jsx)(n.p,{children:"For certain tools that are hard to automatically install\u2014such as Docker or language interpreters\u2014you may want to assume that the user already has the tool installed on their machine."}),"\n",(0,i.jsxs)(n.p,{children:["The simplest approach is to assume that the binary is installed at a fixed absolute path, such as ",(0,i.jsx)(n.code,{children:"/bin/echo"})," or ",(0,i.jsx)(n.code,{children:"/usr/bin/perl"}),". In the ",(0,i.jsx)(n.code,{children:"argv"})," for your ",(0,i.jsx)(n.code,{children:"Process"}),", use this absolute path as your first element."]}),"\n",(0,i.jsxs)(n.p,{children:["If you instead want to allow the binary to be located anywhere on a user's machine, you can use ",(0,i.jsx)(n.code,{children:"BinaryPaths"})," to search certain directories\u2014such as a user's ",(0,i.jsx)(n.code,{children:"$PATH"}),"\u2014to find the absolute path to the binary."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from pants.core.util_rules.system_binaries import (\n    BinaryPathRequest,\n    BinaryPaths,\n    ProcessResult,\n    Process,\n)\n\n@rule\nasync def demo(...) -> Foo:\n    docker_paths = await Get(\n        BinaryPaths,\n        BinaryPathRequest(\n            binary_name="docker",\n            search_path=["/usr/bin", "/bin"],\n        )\n    )\n    docker_bin = docker_paths.first_path\n    if docker_bin is None:\n        raise OSError("Could not find \'docker\'.")\n    result = await Get(ProcessResult, Process(argv=[docker_bin.path, ...], ...)\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"BinaryPaths"})," has a field called ",(0,i.jsx)(n.code,{children:"paths: tuple[BinaryPath, ...]"}),", which stores all the discovered absolute paths to the specified binary. Each ",(0,i.jsx)(n.code,{children:"BinaryPath"})," object has the fields ",(0,i.jsx)(n.code,{children:"path: str"}),", such as ",(0,i.jsx)(n.code,{children:"/usr/bin/docker"}),", and ",(0,i.jsx)(n.code,{children:"fingerprint: str"}),", which is used to invalidate the cache if the binary changes. The results will be ordered by the order of ",(0,i.jsx)(n.code,{children:"search_path"}),", meaning that earlier entries in ",(0,i.jsx)(n.code,{children:"search_path"})," will show up earlier in the result."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"BinaryPaths"})," also has a convenience property called ",(0,i.jsx)(n.code,{children:"first_path: BinaryPath | None"}),", which will return the first matching path, if any."]}),"\n",(0,i.jsxs)(n.p,{children:["In this example, the ",(0,i.jsx)(n.code,{children:"search_path"})," is hardcoded. Instead, you may want to create a ",(0,i.jsx)(n.a,{href:"/2.13/docs/writing-plugins/the-rules-api/options-and-subsystems",children:"subsystem"})," to allow users to override the search path through a dedicated option. See ",(0,i.jsx)(n.a,{href:"https://github.com/pantsbuild/pants/blob/57a47457bda0b0dfb0882d851ccd58a7535f15c1/src/python/pants/backend/python/rules/pex_environment.py#L60-L71",children:"pex_environment.py"})," for an example that allows the user to use the special string ",(0,i.jsx)(n.code,{children:"<PATH>"})," to read the user's ",(0,i.jsx)(n.code,{children:"$PATH"})," environment variable."]}),"\n",(0,i.jsxs)(n.admonition,{title:"Checking for valid binaries (recommended)",type:"note",children:[(0,i.jsxs)(n.p,{children:["When setting up a ",(0,i.jsx)(n.code,{children:"BinaryPathsRequest"}),", you can optionally pass the argument ",(0,i.jsx)(n.code,{children:"test: BinaryPathTest"}),". When discovering a binary, Pants will run your test and only use the binary if the return code is 0. Pants will also fingerprint the output and invalidate the cache if the output changes from before, such as because the user upgraded the version of the tool."]}),(0,i.jsx)(n.p,{children:"Why do this? This is helpful to ensure that all discovered binaries are valid and safe. This is also important for Pants to be able to detect when the user has changed the binary, such as upgrading its version."}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"BinaryPathTest"})," takes the argument ",(0,i.jsx)(n.code,{children:"args: Iterable[str]"}),", which is the arguments that Pants should run on your binary to ensure that it's a valid program. Usually, you'll set ",(0,i.jsx)(n.code,{children:'args=["--version"]'}),"."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from pants.core.util_rules.system_binaries import BinaryPathRequest, BinaryPathTest\n\nBinaryPathRequest(\n    binary_name="docker",\n    search_path=["/usr/bin", "/bin"],\n    test=BinaryPathTest(args=["--version"]),\n)\n'})}),(0,i.jsxs)(n.p,{children:["You can optionally set ",(0,i.jsx)(n.code,{children:"fingerprint_stdout=False"})," to the ",(0,i.jsx)(n.code,{children:"BinaryPathTest"})," constructor, but usually, you should keep the default of ",(0,i.jsx)(n.code,{children:"True"}),"."]})]}),"\n",(0,i.jsxs)(n.h2,{id:"externaltool-install-pre-compiled-binaries",children:[(0,i.jsx)(n.code,{children:"ExternalTool"}),": Install pre-compiled binaries"]}),"\n",(0,i.jsx)(n.p,{children:"If your tool has a pre-compiled binary available online, Pants can download and use that binary automatically for users. This is often a better user experience than requiring the users to pre-install the tool. This will also make your build more deterministic because everyone will be using the same binary."}),"\n",(0,i.jsxs)(n.p,{children:["First, manually download the file. Typically, the downloaded file will be an archive like a ",(0,i.jsx)(n.code,{children:".zip"})," or ",(0,i.jsx)(n.code,{children:".tar.xz"})," file, but it may also be the actual binary. Then, run ",(0,i.jsx)(n.code,{children:"shasum -a 256"})," on the downloaded file to get its digest ID, and ",(0,i.jsx)(n.code,{children:"wc -c"})," to get its number of bytes."]}),"\n",(0,i.jsxs)(n.p,{children:["If the downloaded file is an archive, you will also need to find the relative path within the archive to the binary, such as ",(0,i.jsx)(n.code,{children:"bin/shellcheck"}),". You may need to use a tool like ",(0,i.jsx)(n.code,{children:"unzip"})," to inspect the archive."]}),"\n",(0,i.jsxs)(n.p,{children:["With this information, you can define a new ",(0,i.jsx)(n.code,{children:"ExternalTool"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from pants.core.util_rules.external_tool import ExternalTool\nfrom pants.engine.platform import Platform\n\nclass Shellcheck(ExternalTool):\n    options_scope = "shellcheck"\n    help = "A linter for shell scripts."\n\n    default_version = "v0.7.1"\n    default_known_versions = [\n        "v0.7.1|macos_arm64 |b080c3b659f7286e27004aa33759664d91e15ef2498ac709a452445d47e3ac23|1348272",\n        "v0.7.1|macos_x86_64|b080c3b659f7286e27004aa33759664d91e15ef2498ac709a452445d47e3ac23|1348272",\n        "v0.7.1|linux_arm64 |b50cc31509b354ab5bbfc160bc0967567ed98cd9308fd43f38551b36cccc4446|1432492",\n        "v0.7.1|linux_x86_64|64f17152d96d7ec261ad3086ed42d18232fcb65148b44571b564d688269d36c8|1443836",\n    ]\n\n    def generate_url(self, plat: Platform) -> str:\n        platform_mapping = {\n            "macos_arm64": "darwin.x86_64",\n            "macos_x86_64": "darwin.x86_64",\n            "linux_arm64": "linux.aarch64",\n            "linux_x86_64": "linux.x86_64",\n        }\n        plat_str = platform_mapping[plat.value]\n        return (\n            f"https://github.com/koalaman/shellcheck/releases/download/{self.version}/"\n            f"shellcheck-{self.version}.{plat_str}.tar.xz"\n        )\n\n    def generate_exe(self, _: Platform) -> str:\n        return f"./shellcheck-{self.version}/shellcheck"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["You must define the class properties ",(0,i.jsx)(n.code,{children:"default_version"})," and ",(0,i.jsx)(n.code,{children:"default_known_version"}),". ",(0,i.jsx)(n.code,{children:"default_known_version"})," is a list of pipe-separated strings in the form ",(0,i.jsx)(n.code,{children:"version|platform|sha256|length"}),". Use the values you found earlier by running ",(0,i.jsx)(n.code,{children:"shasum"})," and ",(0,i.jsx)(n.code,{children:"wc"})," for sha256 and length, respectively. ",(0,i.jsx)(n.code,{children:"platform"})," should be one of ",(0,i.jsx)(n.code,{children:"linux_arm64"}),", ",(0,i.jsx)(n.code,{children:"linux_x86_64"}),", ",(0,i.jsx)(n.code,{children:"macos_arm64"}),", and ",(0,i.jsx)(n.code,{children:"macos_x86_64"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["You must also define the methods ",(0,i.jsx)(n.code,{children:"generate_url"}),", which is the URL to make a GET request to download the file, and ",(0,i.jsx)(n.code,{children:"generate_exe"}),", which is the relative path to the binary in the downloaded digest. Both methods take ",(0,i.jsx)(n.code,{children:"plat: Platform"})," as a parameter."]}),"\n",(0,i.jsxs)(n.p,{children:["Because an ",(0,i.jsx)(n.code,{children:"ExternalTool"})," is a subclass of ",(0,i.jsx)(n.a,{href:"/2.13/docs/writing-plugins/the-rules-api/options-and-subsystems",children:(0,i.jsx)(n.code,{children:"Subsystem"})}),", you must also define an ",(0,i.jsx)(n.code,{children:"options_scope"}),". You may optionally register additional options from ",(0,i.jsx)(n.code,{children:"pants.option.option_types"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["In your rules, include the ",(0,i.jsx)(n.code,{children:"ExternalTool"})," as a parameter of the rule, then use ",(0,i.jsx)(n.code,{children:"Get(DownloadedExternalTool, ExternalToolRequest)"})," to download and extract the tool."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from pants.core.util_rules.external_tool import DownloadedExternalTool, ExternalToolRequest\nfrom pants.engine.platform import Platform\n\n@rule\nasync def demo(shellcheck: Shellcheck, ...) -> Foo:\n    shellcheck = await Get(\n        DownloadedExternalTool,\n        ExternalToolRequest,\n        shellcheck.get_request(Platform.current)\n    )\n    result = await Get(\n        ProcessResult,\n        Process(argv=[shellcheck.exe, ...], input_digest=shellcheck.digest, ...)\n    )\n"})}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"DownloadedExternalTool"})," object has two fields: ",(0,i.jsx)(n.code,{children:"digest: Digest"})," and ",(0,i.jsx)(n.code,{children:"exe: str"}),". Use the ",(0,i.jsx)(n.code,{children:".exe"})," field as the first value of a ",(0,i.jsx)(n.code,{children:"Process"}),"'s ",(0,i.jsx)(n.code,{children:"argv"}),", and use the ",(0,i.jsx)(n.code,{children:".digest"})," in the ",(0,i.jsx)(n.code,{children:"Process's"})," ",(0,i.jsx)(n.code,{children:"input_digest"}),". If you want to use multiple digests for the input, call ",(0,i.jsx)(n.code,{children:"Get(Digest, MergeDigests)"})," with the ",(0,i.jsx)(n.code,{children:"DownloadedExternalTool.digest"})," included."]}),"\n",(0,i.jsxs)(n.h2,{id:"pex-install-binaries-through-pip",children:[(0,i.jsx)(n.code,{children:"Pex"}),": Install binaries through pip"]}),"\n",(0,i.jsxs)(n.p,{children:["If a tool can be installed via ",(0,i.jsx)(n.code,{children:"pip"})," - e.g., Pytest or Black - you can install and run it using ",(0,i.jsx)(n.code,{children:"Pex"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from pants.backend.python.target_types import ConsoleScript\nfrom pants.backend.python.util_rules.interpreter_constraints import InterpreterConstraints\nfrom pants.backend.python.util_rules.pex import (\n    Pex,\n    PexProcess,\n    PexRequest,\n    PexRequirements,\n)\nfrom pants.engine.process import FallibleProcessResult\n\n@rule\nasync def demo(...) -> Foo:\n    pex = await Get(\n        Pex,\n        PexRequest(\n            output_filename="black.pex",\n            internal_only=True,\n            requirements=PexRequirements(["black==19.10b0"]),\n            interpreter_constraints=InterpreterConstraints([">=3.6"]),\n            main=ConsoleScript("black"),\n        )\n    )\n    result = await Get(\n        FallibleProcessResult,\n        PexProcess(pex, argv=["--check", ...], ...),\n    )\n'})}),"\n",(0,i.jsxs)(n.p,{children:["When defining a ",(0,i.jsx)(n.code,{children:"PexRequest"})," for a tool, you must give arguments for ",(0,i.jsx)(n.code,{children:"output_filename"}),", ",(0,i.jsx)(n.code,{children:"internal_only"}),", ",(0,i.jsx)(n.code,{children:"requirements"}),", ",(0,i.jsx)(n.code,{children:"main"}),", and usually ",(0,i.jsx)(n.code,{children:"interpreter_constraints"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Set ",(0,i.jsx)(n.code,{children:"internal_only"})," if the PEX is only used as an internal tool, rather than distributed to users (e.g. the ",(0,i.jsx)(n.code,{children:"package"})," goal). This speeds up performance when building the PEX."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"main"})," argument can be one of:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'ConsoleScript("scriptname")'}),", where ",(0,i.jsx)(n.code,{children:"scriptname"})," is a ",(0,i.jsx)(n.a,{href:"https://packaging.python.org/specifications/entry-points/",children:"console_script"})," that the tool installs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'EntryPoint.parse("module")'}),", which executes the given module"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'EntryPoint.parse("module:func")'}),", which executes the given nullary function in the given module."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"There are several other optional parameters that may be helpful."}),"\n",(0,i.jsxs)(n.p,{children:["The resulting ",(0,i.jsx)(n.code,{children:"Pex"})," object has a ",(0,i.jsx)(n.code,{children:"digest: Digest"})," field containing the built ",(0,i.jsx)(n.code,{children:".pex"})," file. This digest should be included in the ",(0,i.jsx)(n.code,{children:"input_digest"})," to the ",(0,i.jsx)(n.code,{children:"Process"})," you run."]}),"\n",(0,i.jsxs)(n.p,{children:["Instead of the normal ",(0,i.jsx)(n.code,{children:"Get(ProcessResult, Process)"}),", you should use ",(0,i.jsx)(n.code,{children:"Get(ProcessResult, PexProcess)"}),", which will set up the environment properly for your Pex to execute. There is a predefined rule to go from ",(0,i.jsx)(n.code,{children:"PexProcess -> Process"}),", so ",(0,i.jsx)(n.code,{children:"Get(ProcessResult, Process)"})," will cause the engine to run ",(0,i.jsx)(n.code,{children:"PexProcess -> Process -> ProcessResult"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"PexProcess"})," requires arguments for ",(0,i.jsx)(n.code,{children:"pex: Pex"}),", ",(0,i.jsx)(n.code,{children:"argv: Iterable[str]"}),", and ",(0,i.jsx)(n.code,{children:"description: str"}),". It has several optional parameters that mirror the arguments to ",(0,i.jsx)(n.code,{children:"Process"}),". If you specify ",(0,i.jsx)(n.code,{children:"input_digest"}),", be careful to first use ",(0,i.jsx)(n.code,{children:"Get(Digest, MergeDigests)"})," on the ",(0,i.jsx)(n.code,{children:"pex.digest"})," and any of the other input digests."]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.mdxAdmonitionTitle,{children:["Use ",(0,i.jsx)(n.code,{children:"PythonToolBase"})," when you need a Subsystem"]}),(0,i.jsxs)(n.p,{children:["Often, you will want to create a ",(0,i.jsx)(n.a,{href:"/2.13/docs/writing-plugins/the-rules-api/options-and-subsystems",children:(0,i.jsx)(n.code,{children:"Subsystem"})})," for your Python tool\nto allow users to set options to configure the tool. You can subclass ",(0,i.jsx)(n.code,{children:"PythonToolBase"}),", which\nsubclasses ",(0,i.jsx)(n.code,{children:"Subsystem"}),", to do this:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from pants.backend.python.subsystems.python_tool_base import PythonToolBase\nfrom pants.backend.python.target_types import ConsoleScript\nfrom pants.option.option_types import StrOption\n\nclass Black(PythonToolBase):\n    options_scope = "black"\n    help = "The Black Python code formatter (https://black.readthedocs.io/)."\n\n    default_version = "black==19.10b0"\n    default_extra_requirements = ["setuptools"]\n    default_main = ConsoleScript("black")\n    default_interpreter_constraints = ["CPython>=3.6"]\n\n    config = StrOption(\n        "--config",\n        default=None,\n        advanced=True,\n        help="Path to Black\'s pyproject.toml config file",\n    )\n'})}),(0,i.jsxs)(n.p,{children:["You must define the class properties ",(0,i.jsx)(n.code,{children:"options_scope"}),", ",(0,i.jsx)(n.code,{children:"default_version"}),", and ",(0,i.jsx)(n.code,{children:"default_main"}),". You\ncan optionally define ",(0,i.jsx)(n.code,{children:"default_extra_requirements"})," and ",(0,i.jsx)(n.code,{children:"default_interpreter_constraints"}),"."]}),(0,i.jsxs)(n.p,{children:["Then, you can set up your ",(0,i.jsx)(n.code,{children:"Pex"})," like this:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"@rule\nasync def demo(black: Black, ...) -> Foo:\n    pex = await Get(Pex, PexRequest, black.to_pex_request())\n"})})]})]})}function h(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},848193(e,n,s){s.d(n,{R:()=>o,x:()=>a});var t=s(830758);let i={},r=t.createContext(i);function o(e){let n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},27085(e){e.exports=JSON.parse('{"id":"docs/writing-plugins/the-rules-api/installing-tools","title":"Installing tools","description":"Various methods for Pants to access the tools your plugin needs.","source":"@site/versioned_docs/version-2.13/docs/writing-plugins/the-rules-api/installing-tools.mdx","sourceDirName":"docs/writing-plugins/the-rules-api","slug":"/docs/writing-plugins/the-rules-api/installing-tools","permalink":"/2.13/docs/writing-plugins/the-rules-api/installing-tools","draft":false,"unlisted":false,"editUrl":"https://github.com/pantsbuild/pants/edit/main/docs/docs/writing-plugins/the-rules-api/installing-tools.mdx","tags":[],"version":"2.13","sidebarPosition":5,"frontMatter":{"title":"Installing tools","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Processes","permalink":"/2.13/docs/writing-plugins/the-rules-api/processes"},"next":{"title":"Rules and the Target API","permalink":"/2.13/docs/writing-plugins/the-rules-api/rules-and-the-target-api"}}')}}]);