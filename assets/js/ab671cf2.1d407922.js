"use strict";(self.webpackChunkpantsbuild_org=self.webpackChunkpantsbuild_org||[]).push([["166676"],{269356(e,t,n){n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>u});var r=n(103181),s=n(886070),i=n(848193);let o={title:"Testing plugins",sidebar_position:2},a,l={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Testing with a complete Pants process",id:"testing-with-a-complete-pants-process",level:3},{value:"Testing goal rules",id:"testing-goal-rules",level:3},{value:"Testing individual rules",id:"testing-individual-rules",level:3},{value:"Unit testing for rules",id:"unit-testing-for-rules",level:3}];function c(e){let t={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"How to write tests for your custom plugin code."}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(t.p,{children:["In this tutorial, we'll learn how to test the custom plugin we wrote earlier. Pants documentation provides comprehensive coverage of the ",(0,s.jsx)(t.a,{href:"/2.16/docs/writing-plugins/the-rules-api/testing-plugins",children:"plugin testing"})," and this tutorial should help you get started writing own tests."]}),"\n",(0,s.jsx)(t.p,{children:"Most of the plugin code that needs to be tested is in the following files:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"rules.py"})," where we implemented how a ",(0,s.jsx)(t.code,{children:"VERSION"})," file needs to be read and how to use a ",(0,s.jsx)(t.code,{children:"version_file"})," BUILD target"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"tailor.py"})," where we taught the ",(0,s.jsx)(t.code,{children:"tailor"})," goal about the ",(0,s.jsx)(t.code,{children:"VERSION"})," files and generation of ",(0,s.jsx)(t.code,{children:"version_file"})," targets"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["To author a test suite, it may make sense to write a very high level test first to confirm our code does what we expect. Let's write some ",(0,s.jsx)(t.a,{href:"/2.16/docs/writing-plugins/the-rules-api/testing-plugins#approach-4-run_pants-integration-tests-for-pants",children:"integration tests for Pants"})," so that we could run our goal from a test!"]}),"\n",(0,s.jsx)(t.h3,{id:"testing-with-a-complete-pants-process",children:"Testing with a complete Pants process"}),"\n",(0,s.jsxs)(t.p,{children:["Pants provides a convenient way to run a full Pants process as it would run on the command line. Writing such a test would be equal to having, say, a Shell script to confirm that the output of the ",(0,s.jsx)(t.code,{children:"pants project-version myapp:"})," command is ",(0,s.jsx)(t.code,{children:'{"path": "myapp/VERSION", "version": "0.0.1"}'}),". Keep in mind that running custom scripts with this type of tests would require having a Pants repository set up (including the ",(0,s.jsx)(t.code,{children:"pants.toml"})," configuration), creating ",(0,s.jsx)(t.code,{children:"BUILD"})," metadata files and so on. When writing custom acceptance tests using ",(0,s.jsx)(t.code,{children:"pants.testutil"})," package, you, in contrast, don't have to worry about that and can focus on testing your plugin logic in the very minimalistic environment containing only what's absolutely necessary to run your plugin code."]}),"\n",(0,s.jsxs)(t.p,{children:["In the following code snippet, we define a set of files to be created (in a temporary directory that Pants manages for us), the backends to be used (Python and our custom plugin), and a Pants command to be run. By reading the ",(0,s.jsx)(t.code,{children:"stdout"})," of a process, we can confirm the plugin works as expected (conveniently ignoring any unrelated warnings that Pants may have produced)."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'import json\nfrom pathlib import Path\n\nfrom pants.testutil.pants_integration_test import run_pants, setup_tmpdir\n\nbuild_root_marker = Path.cwd().joinpath("BUILDROOT")\n\n\ndef test_reading_project_version_target() -> None:\n    """Run a full Pants process as it would run on the command line."""\n    project_files = {\n        "project/BUILD": "version_file(source=\'VERSION\')",\n        "project/VERSION": "10.6.1",\n    }\n    # This is a limitation of the current implementation.\n    # See https://github.com/pantsbuild/pants/issues/12760.\n    build_root_marker.touch()\n    with setup_tmpdir(project_files) as tmpdir:\n        result = run_pants(\n            [\n                (\n                    "--backend-packages="\n                    "[\'pants.backend.python\', \'internal_plugins.project_version\']"\n                ),\n                "project-version",\n                "--as-json",\n                f"{tmpdir}/project:",\n            ],\n        )\n        result.assert_success()\n        assert result.stdout.strip() == json.dumps(\n            {"path": f"{tmpdir}/project/VERSION", "version": "10.6.1"}\n        )\n    build_root_marker.unlink()\n'})}),"\n",(0,s.jsxs)(t.p,{children:["These tests do not need any special bootstrapping and can be run just like any other tests you may have in the repository with the ",(0,s.jsx)(t.code,{children:"test"})," goal. They, however, are slow, and if there are lots of test cases to check (e.g. you want to test usage of flags and targets with various fields set), it may soon become impractical to run them often enough. You would most likely want to test your plugin logic in a more isolated fashion."]}),"\n",(0,s.jsx)(t.h3,{id:"testing-goal-rules",children:"Testing goal rules"}),"\n",(0,s.jsxs)(t.p,{children:["You can exercise the goal rule by using ",(0,s.jsx)(t.a,{href:"/2.16/docs/writing-plugins/the-rules-api/testing-plugins#testing-goal_rules",children:(0,s.jsx)(t.code,{children:"rule_runner.run_goal_rule()"})})," which runs very fast and does not start a full Pants process. In the test below, we register all rules from the ",(0,s.jsx)(t.code,{children:"project_version"})," plugin with the ",(0,s.jsx)(t.code,{children:"RuleRunner"})," so that the engine can find them when a test is run. These tests scale nicely and if your plugins are fairly simple, they may suffice."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'import pytest\nfrom pants.engine.internals.scheduler import ExecutionError\nfrom pants.testutil.rule_runner import RuleRunner\n\nfrom internal_plugins.project_version.rules import ProjectVersionGoal\nfrom internal_plugins.project_version.rules import rules as project_version_rules\nfrom internal_plugins.project_version.target_types import ProjectVersionTarget\n\n\n@pytest.fixture\ndef rule_runner() -> RuleRunner:\n    return RuleRunner(\n        rules=project_version_rules(), target_types=[ProjectVersionTarget]\n    )\n\n\ndef test_project_version_goal(rule_runner: RuleRunner) -> None:\n    """Test a `project-version` goal using VERSION files."""\n    rule_runner.write_files(\n        {\n            "project/VERSION": "10.6.1",\n            "project/BUILD": "version_file(source=\'VERSION\')",\n        }\n    )\n    result = rule_runner.run_goal_rule(\n        ProjectVersionGoal, args=["--as-json", "project:"]\n    )\n    assert result.stdout.splitlines() == [\n        \'{"path": "project/VERSION", "version": "10.6.1"}\'\n    ]\n\n    # Invalid version string is provided.\n    rule_runner.write_files(\n        {\n            "project/VERSION": "foo.bar",\n            "project/BUILD": "version_file(source=\'VERSION\')",\n        }\n    )\n    with pytest.raises(ExecutionError):\n        rule_runner.run_goal_rule(ProjectVersionGoal, args=["project:"])\n'})}),"\n",(0,s.jsx)(t.h3,{id:"testing-individual-rules",children:"Testing individual rules"}),"\n",(0,s.jsxs)(t.p,{children:["If your plugin is more sophisticated, and there are many rules, you may want to test them in isolation. In our plugin, there are a couple of rules we could write tests for. For example, the ",(0,s.jsx)(t.code,{children:"get_project_version_file_view"})," rule reads a target and returns an instance of ",(0,s.jsx)(t.code,{children:"dataclass"}),", namely ",(0,s.jsx)(t.code,{children:"ProjectVersionFileView"}),". This looks like a good candidate for a very isolated test."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'import pytest\nfrom pants.build_graph.address import Address\nfrom pants.testutil.rule_runner import QueryRule, RuleRunner\n\nfrom internal_plugins.project_version.rules import (\n    ProjectVersionFileView,\n    get_project_version_file_view,\n)\nfrom internal_plugins.project_version.target_types import ProjectVersionTarget\n\n\n@pytest.fixture\ndef rule_runner() -> RuleRunner:\n    return RuleRunner(\n        rules=[\n            get_project_version_file_view,\n            QueryRule(ProjectVersionFileView, [ProjectVersionTarget]),\n        ],\n        target_types=[ProjectVersionTarget],\n    )\n\n\ndef test_get_project_version_file_view(rule_runner: RuleRunner) -> None:\n    """Test plugin rules in isolation (not specifying what rules need to be run)."""\n    rule_runner.write_files(\n        {"project/VERSION": "10.6.1", "project/BUILD": "version_file(source=\'VERSION\')"}\n    )\n    target = rule_runner.get_target(Address("project", target_name="project"))\n    result = rule_runner.request(ProjectVersionFileView, [target])\n    assert result == ProjectVersionFileView(path="project/VERSION", version="10.6.1")\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Since we have extended the ",(0,s.jsx)(t.code,{children:"tailor"})," goal to generate ",(0,s.jsx)(t.code,{children:"version_file"})," targets in the directories containing ",(0,s.jsx)(t.code,{children:"VERSION"})," files, let's write a test to confirm the goal does what we want. For this, we can continue using the ",(0,s.jsx)(t.a,{href:"/2.16/docs/writing-plugins/the-rules-api/testing-plugins#running-your-rules",children:(0,s.jsx)(t.code,{children:"RuleRunner"})}),". Let's create a temporary build root, write necessary files, and then ask Pants to get a list of targets that it would have created for us."]}),"\n",(0,s.jsxs)(t.p,{children:["It's often very difficult to know how testing of a particular functionality is done, so it's worth taking a look at the Pants codebase. For instance, this ",(0,s.jsx)(t.code,{children:"tailor"})," test has been adopted from this ",(0,s.jsx)(t.a,{href:"https://github.com/pantsbuild/pants/blob/8cb558592d00b228182e6bbcb667705dad73bb95/src/python/pants/backend/cc/goals/tailor_test.py#L1-L0",children:"test suite"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from pathlib import Path\n\nimport pytest\nfrom pants.core.goals.tailor import AllOwnedSources, PutativeTarget, PutativeTargets\nfrom pants.engine.rules import QueryRule\nfrom pants.testutil.rule_runner import RuleRunner\nfrom pants.util.frozendict import FrozenDict\n\nfrom internal_plugins.project_version.tailor import (\n    PutativeProjectVersionTargetsRequest,\n    rules,\n)\nfrom internal_plugins.project_version.target_types import ProjectVersionTarget\n\n\n@pytest.fixture\ndef rule_runner() -> RuleRunner:\n    return RuleRunner(\n        rules=[\n            *rules(),\n            QueryRule(\n                PutativeTargets, (PutativeProjectVersionTargetsRequest, AllOwnedSources)\n            ),\n        ],\n        target_types=[ProjectVersionTarget],\n    )\n\n\ndef test_find_putative_avnpkg_files_targets(rule_runner: RuleRunner) -> None:\n    """Test generating `version_file` targets in a project directory."""\n    files = {\n        "project/dir1/VERSION": "10.6.1",\n        "project/dir2/file.txt": "",\n        "project/dir3/VERSION": "10.7.1",\n        # Note that dir3/VERSION already has the target and should be ignored.\n        "project/dir3/BUILD": "version_file(source=\'VERSION\')",\n    }\n    rule_runner.write_files(files)\n    for filepath, _ in files.items():\n        assert Path(rule_runner.build_root, filepath).exists()\n\n    putative_targets = rule_runner.request(\n        PutativeTargets,\n        [\n            PutativeProjectVersionTargetsRequest(\n                ("project/dir1", "project/dir2", "project/dir3"),\n            ),\n            # Declare that all these files in the project are already owned by targets.\n            AllOwnedSources(["project/dir2/file.txt", "project/dir3/VERSION"]),\n        ],\n    )\n\n    assert (\n        PutativeTargets(\n            [\n                PutativeTarget(\n                    path="project/dir1",\n                    name="project-version-file",\n                    type_alias="version_file",\n                    triggering_sources=("VERSION",),\n                    owned_sources=("VERSION",),\n                    kwargs=FrozenDict({}),\n                    comments=(),\n                )\n            ]\n        )\n        == putative_targets\n    )\n'})}),"\n",(0,s.jsx)(t.h3,{id:"unit-testing-for-rules",children:"Unit testing for rules"}),"\n",(0,s.jsxs)(t.p,{children:["Finally, if your plugin is very complex and would benefit from a more rigorous testing, you may consider writing ",(0,s.jsx)(t.a,{href:"/2.16/docs/writing-plugins/the-rules-api/testing-plugins#approach-2-run_rule_with_mocks-unit-tests-for-rules",children:"unit tests for the rules"})," where some parts of the rules are going to be patched with mocks. For instance, there's ",(0,s.jsx)(t.code,{children:"get_git_repo_version"})," rule which calls Git (in a subprocess) to describe the repository status. We could mock the ",(0,s.jsx)(t.code,{children:"Process"})," call to make sure the inline logic of the rule is correct instead."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from unittest.mock import Mock\n\nfrom pants.base.build_root import BuildRoot\nfrom pants.core.util_rules.system_binaries import (\n    BinaryPath,\n    BinaryPathRequest,\n    BinaryPaths,\n)\nfrom pants.engine.process import Process, ProcessResult\nfrom pants.testutil.rule_runner import MockGet, run_rule_with_mocks\n\nfrom internal_plugins.project_version.rules import GitTagVersion, get_git_repo_version\n\n\ndef test_get_git_version() -> None:\n    """Test running a specific rule returning a GitVersion."""\n\n    def mock_binary_paths(request: BinaryPathRequest) -> BinaryPaths:\n        return BinaryPaths(binary_name="git", paths=[BinaryPath("/usr/bin/git")])\n\n    def mock_process_git_describe(process: Process) -> ProcessResult:\n        return Mock(stdout=b"10.6.1\\n")\n\n    result: GitTagVersion = run_rule_with_mocks(\n        get_git_repo_version,\n        rule_args=[BuildRoot, ""],\n        mock_gets=[\n            MockGet(\n                output_type=BinaryPaths,\n                input_types=(BinaryPathRequest,),\n                mock=mock_binary_paths,\n            ),\n            MockGet(\n                output_type=ProcessResult,\n                input_types=(Process,),\n                mock=mock_process_git_describe,\n            ),\n        ],\n    )\n    assert result == GitTagVersion("10.6.1")\n'})}),"\n",(0,s.jsx)(t.p,{children:"You could write the helper functions returning the mock objects as lambdas, if you like, for instance:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'MockGet(\n    output_type=BinaryPaths,\n    input_types=(BinaryPathRequest,),\n    mock=lambda request: BinaryPaths(binary_name="git", paths=[BinaryPath("/usr/bin/git")]),\n),\n'})}),"\n",(0,s.jsxs)(t.p,{children:["however if you have many ",(0,s.jsx)(t.code,{children:"Get"})," requests that are being mocked, because ",(0,s.jsx)(t.code,{children:"lambda"}),"'s syntax does not support type annotations, it can make your tests slightly harder to read. For instance, in the example above, the type of the ",(0,s.jsx)(t.code,{children:"request"})," argument is unknown."]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:"This concludes the series of tutorials that should help you get started writing own plugins with Pants. We have by now done quite a lot of work! You have learned:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"how to create an own goal, custom options and custom targets"}),"\n",(0,s.jsxs)(t.li,{children:["how to extend existing Pants goals such as ",(0,s.jsx)(t.code,{children:"tailor"})]}),"\n",(0,s.jsx)(t.li,{children:"how to run system tools in your plugins and how Pants interacts with the file system"}),"\n",(0,s.jsx)(t.li,{children:"how to write unit and integration tests for your plugin code"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"You are now ready to design and implement your next Pants plugin!"})]})}function d(e={}){let{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},848193(e,t,n){n.d(t,{R:()=>o,x:()=>a});var r=n(830758);let s={},i=r.createContext(s);function o(e){let t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:t},e.children)}},103181(e){e.exports=JSON.parse('{"id":"docs/tutorials/testing-plugins","title":"Testing plugins","description":"How to write tests for your custom plugin code.","source":"@site/versioned_docs/version-2.16/docs/tutorials/testing-plugins.mdx","sourceDirName":"docs/tutorials","slug":"/docs/tutorials/testing-plugins","permalink":"/2.16/docs/tutorials/testing-plugins","draft":false,"unlisted":false,"editUrl":"https://github.com/pantsbuild/pants/edit/main/docs/docs/tutorials/testing-plugins.mdx","tags":[],"version":"2.16","sidebarPosition":2,"frontMatter":{"title":"Testing plugins","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Advanced plugin concepts","permalink":"/2.16/docs/tutorials/advanced-plugin-concepts"}}')}}]);