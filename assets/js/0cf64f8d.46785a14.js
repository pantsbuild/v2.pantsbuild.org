"use strict";(self.webpackChunkpantsbuild_org=self.webpackChunkpantsbuild_org||[]).push([["498875"],{844337(e,s,n){n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>a});var t=n(984754),r=n(886070),i=n(848193);let d={title:"Rules and the Target API",sidebar_position:6},o,l={},a=[{value:"How to read values from a <code>Target</code>",id:"how-to-read-values-from-a-target",level:2},{value:"<code>Field</code> subclasses",id:"field-subclasses",level:3},{value:"A Target&#39;s <code>Address</code>",id:"a-targets-address",level:3},{value:"How to resolve targets",id:"how-to-resolve-targets",level:2},{value:"The <code>Dependencies</code> field",id:"the-dependencies-field",level:2},{value:"Transitive dependencies with <code>TransitiveTargets</code>",id:"transitive-dependencies-with-transitivetargets",level:3},{value:"Dependencies-like fields",id:"dependencies-like-fields",level:3},{value:"<code>SourcesField</code>",id:"sourcesfield",level:2},{value:"Enabling codegen",id:"enabling-codegen",level:3},{value:"Stripping source roots",id:"stripping-source-roots",level:3},{value:"<code>FieldSet</code>s",id:"fieldsets",level:2}];function c(e){let s={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.p,{children:"How to use the Target API in rules."}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsxs)(s.p,{children:["Start by reading the ",(0,r.jsx)(s.a,{href:"/2.28/docs/writing-plugins/the-target-api/concepts",children:"Concepts"})," of the Target API."]}),"\n",(0,r.jsxs)(s.p,{children:["Note that the engine does not have special knowledge about ",(0,r.jsx)(s.code,{children:"Target"}),"s and ",(0,r.jsx)(s.code,{children:"Field"}),"s. To the engine, these are like any other types you'd use, and the ",(0,r.jsx)(s.code,{children:"@rule"}),"s to work with targets are like any other ",(0,r.jsx)(s.code,{children:"@rule"}),"."]}),"\n",(0,r.jsxs)(s.h2,{id:"how-to-read-values-from-a-target",children:["How to read values from a ",(0,r.jsx)(s.code,{children:"Target"})]}),"\n",(0,r.jsxs)(s.p,{children:["As explained in ",(0,r.jsx)(s.a,{href:"/2.28/docs/writing-plugins/the-target-api/concepts",children:"Concepts"}),", a ",(0,r.jsx)(s.code,{children:"Target"})," is an addressable combination of fields, where each field gives some metadata about your code."]}),"\n",(0,r.jsxs)(s.p,{children:["To read a particular ",(0,r.jsx)(s.code,{children:"Field"})," for a ",(0,r.jsx)(s.code,{children:"Target"}),", look it up with the ",(0,r.jsx)(s.code,{children:"Field"}),"'s class in square brackets, like you would look up a normal Python dictionary:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from pants.backend.python.target_types import PythonTestsTimeoutField\n\ntimeout_field = target[PythonTestsTimeoutField]\nprint(timeout_field.value)\n"})}),"\n",(0,r.jsxs)(s.p,{children:["This will return an instance of the ",(0,r.jsx)(s.code,{children:"Field"})," subclass you looked up, which has two properties: ",(0,r.jsx)(s.code,{children:"alias: str"})," and ",(0,r.jsx)(s.code,{children:"value"}),". The type of ",(0,r.jsx)(s.code,{children:"value"})," depends on the particular field. For example, ",(0,r.jsx)(s.code,{children:"PythonTestsTimeout"})," subclasses ",(0,r.jsx)(s.code,{children:"IntField"}),", so ",(0,r.jsx)(s.code,{children:"value"})," has an ",(0,r.jsx)(s.code,{children:"int"})," type."]}),"\n",(0,r.jsxs)(s.p,{children:["Looking up a field with ",(0,r.jsx)(s.code,{children:"tgt[MyField]"})," will fail if the field is not registered on the target type."]}),"\n",(0,r.jsxs)(s.p,{children:["If the ",(0,r.jsx)(s.code,{children:"Field"})," might not be registered, and you're okay with using a default value, you can instead use the method ",(0,r.jsx)(s.code,{children:".get()"}),". When the ",(0,r.jsx)(s.code,{children:"Field"})," is not registered, this will call the constructor for that ",(0,r.jsx)(s.code,{children:"Field"})," with ",(0,r.jsx)(s.code,{children:"raw_value=None"}),", which is equivalent to if the user left off the field from their BUILD file."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from pants.backend.python.target_types import PythonTestsTimeoutField\n\ntimeout_field = target.get(PythonTestsTimeoutField)\nprint(timeout_field.value)\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Often, you may want to see if a target type has a particular ",(0,r.jsx)(s.code,{children:"Field"})," registered. This is useful to filter targets. Use the methods ",(0,r.jsx)(s.code,{children:".has_field()"})," and ",(0,r.jsx)(s.code,{children:".has_fields()"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'from pants.backend.python.target_types import PythonTestsTimeoutField, PythonSourceField\n\nif target.has_field(PythonSourceField):\n    print("My plugin can work on this target.")\n\nif target.has_fields([PythonSourceField, PythonTestsTimeoutField]):\n    print("The target has both Python sources and a timeout field")\n'})}),"\n",(0,r.jsxs)(s.h3,{id:"field-subclasses",children:[(0,r.jsx)(s.code,{children:"Field"})," subclasses"]}),"\n",(0,r.jsxs)(s.p,{children:["As explained in ",(0,r.jsx)(s.a,{href:"/2.28/docs/writing-plugins/the-target-api/concepts",children:"Concepts"}),", subclassing ",(0,r.jsx)(s.code,{children:"Field"}),"s is key to how the Target API works."]}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"Target"})," methods ",(0,r.jsx)(s.code,{children:"[MyField]"}),", ",(0,r.jsx)(s.code,{children:".has_field()"})," and ",(0,r.jsx)(s.code,{children:".get()"})," understand when a ",(0,r.jsx)(s.code,{children:"Field"})," is subclassed, as follows:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:">>> docker_tgt.has_field(DockerSourceField)\nTrue\n>>> docker_tgt.has_field(SingleSourceField)\nTrue\n>>> python_test_tgt.has_field(DockerSourceField)\nFalse\n>>> python_test_tgt.has_field(SingleSourceField)\nTrue\n"})}),"\n",(0,r.jsxs)(s.p,{children:["This allows you to express specifically which types of ",(0,r.jsx)(s.code,{children:"Field"}),"s you need to work. For example, the ",(0,r.jsx)(s.code,{children:"pants filedeps"})," goal only needs ",(0,r.jsx)(s.code,{children:"SourceField"}),", and works with any subclasses. Meanwhile, Black and isort need ",(0,r.jsx)(s.code,{children:"PythonSourceField"}),", and work with any subclasses. Finally, the Pytest runner needs ",(0,r.jsx)(s.code,{children:"PythonTestSourceField"})," (or any subclass)."]}),"\n",(0,r.jsxs)(s.h3,{id:"a-targets-address",children:["A Target's ",(0,r.jsx)(s.code,{children:"Address"})]}),"\n",(0,r.jsxs)(s.p,{children:["Every target is identified by its ",(0,r.jsx)(s.code,{children:"Address"}),", from ",(0,r.jsx)(s.code,{children:"pants.engine.addresses"}),". Many types used in the Plugin API will use ",(0,r.jsx)(s.code,{children:"Address"})," objects as fields, and it's also often useful to use the ",(0,r.jsx)(s.code,{children:"Address"})," when writing the description for a ",(0,r.jsx)(s.code,{children:"Process"})," you run."]}),"\n",(0,r.jsxs)(s.p,{children:["A ",(0,r.jsx)(s.code,{children:"Target"})," has a field ",(0,r.jsx)(s.code,{children:"address: Address"}),", e.g. ",(0,r.jsx)(s.code,{children:"my_tgt.address"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["You can also create an ",(0,r.jsx)(s.code,{children:"Address"})," object directly, which is often useful in tests:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"project:tgt"})," -> ",(0,r.jsx)(s.code,{children:'Address("project", target_name="tgt")'})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"project/"})," -> ",(0,r.jsx)(s.code,{children:'Address("project")'})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"//:top-level"})," -> ",(0,r.jsx)(s.code,{children:'Address("", target_name="top_level")'})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"project/app.py:tgt"})," -> ",(0,r.jsx)(s.code,{children:'Address("project", target_name="tgt", relative_file_name="app.py")'})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"project:tgt#generated"})," -> ",(0,r.jsx)(s.code,{children:'Address("project", target_name="tgt", generated_name="generated")'})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"project:tgt@shell=zsh"})," -> ",(0,r.jsx)(s.code,{children:'Address("project", target_name="tgt", parameters={"shell": "zsh"})'})]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["You can use ",(0,r.jsx)(s.code,{children:"str(address)"})," or ",(0,r.jsx)(s.code,{children:"address.spec"})," to get the normalized string representation. ",(0,r.jsx)(s.code,{children:"address.spec_path"})," will give the path to the parent directory of the target's original BUILD file."]}),"\n",(0,r.jsx)(s.h2,{id:"how-to-resolve-targets",children:"How to resolve targets"}),"\n",(0,r.jsxs)(s.p,{children:["How do you get ",(0,r.jsx)(s.code,{children:"Target"}),"s in the first place in your plugin?"]}),"\n",(0,r.jsxs)(s.p,{children:["As explained in ",(0,r.jsx)(s.a,{href:"/2.28/docs/writing-plugins/the-rules-api/goal-rules",children:"Goal rules"}),", to get all the targets specified on the command line by a user, you can request the type ",(0,r.jsx)(s.code,{children:"Targets"})," as a parameter to your ",(0,r.jsx)(s.code,{children:"@rule"})," or ",(0,r.jsx)(s.code,{children:"@goal_rule"}),". From there, you can optionally filter out the targets you want, such as by using ",(0,r.jsx)(s.code,{children:"target.has_field()"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'from pants.engine.target import Targets\n\n@rule\nasync def example(targets: Targets) -> Foo:\n    logger.info(f"User specified these targets: {[tgt.address.spec for tgt in targets]}")\n    ...\n'})}),"\n",(0,r.jsxs)(s.p,{children:["(You can also request ",(0,r.jsx)(s.code,{children:"Addresses"})," (from ",(0,r.jsx)(s.code,{children:"pants.engine.addresses"}),") as a parameter to your ",(0,r.jsx)(s.code,{children:"@rule"})," if you only need the addresses specified on the command line by a user.)"]}),"\n",(0,r.jsxs)(s.p,{children:["Use ",(0,r.jsx)(s.code,{children:"AllTargets"})," to instead get all targets defined in the repository."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'from pants.engine.target import AllTargets\n\n@rule\nasync def example(targets: AllTargets) -> Foo:\n    logger.info(f"All targets: {[tgt.address.spec for tgt in targets]}")\n    ...\n'})}),"\n",(0,r.jsxs)(s.p,{children:["For most ",(0,r.jsx)(s.a,{href:"/2.28/docs/writing-plugins/common-plugin-tasks/",children:"Common plugin tasks"}),", like adding a linter, Pants will have already filtered out the relevant targets for you and will pass you only the targets you care about."]}),"\n",(0,r.jsx)(s.p,{children:'Given targets, you can find their direct and transitive dependencies. See the below section "The Dependencies field".'}),"\n",(0,r.jsxs)(s.p,{children:["You can also find targets by writing your own ",(0,r.jsx)(s.code,{children:"Spec"}),"s, rather than using what the user provided. (The types come from ",(0,r.jsx)(s.code,{children:"pants.base.specs"}),".)"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'# Inside an `@rule`, use `await Get` like this.\nawait Get(\n    Targets,\n    RawSpecs(\n        description_of_origin="my plugin",  # Used in error messages for invalid specs.\n        # Each of these keyword args are optional.\n        address_literals=(\n            AddressLiteralSpec("my_dir", target_component="tgt"),  # `my_dir:tgt`\n            AddressLiteralSpec("my_dir", target_component="tgt", generated_component="gen"),  # `my_dir:tgt#gen`\n            AddressLiteralSpec("my_dir/f.ext", target_component="tgt"),  # `my_dir/f.ext:tgt`\n        ),\n        file_literals=(FileLiteralSpec("my_dir/f.ext"),),  # `my_dir/f.ext`\n        file_globs=(FileGlobSpec("my_dir/*.ext"),),  # `my_dir/*.ext`\n        dir_literals=(DirLiteralSpec("my_dir"),),  # `my_dir/`\n        dir_globs=(DirGlobSpec("my_dir"),),  # `my_dir:`\n        recursive_globs=(RecursiveGlobSpec("my_dir"),),  # `my_dir::`\n        ancestor_globs=(AncestorGlobSpec("my_dir"),),  # i.e. `my_dir` and all ancestors\n    )\n)\n'})}),"\n",(0,r.jsxs)(s.p,{children:["Finally, you can look up an ",(0,r.jsx)(s.code,{children:"Address"})," given a raw address string, using ",(0,r.jsx)(s.code,{children:"AddressInput"}),". This is often useful to allow a user to refer to targets in ",(0,r.jsx)(s.a,{href:"/2.28/docs/writing-plugins/the-rules-api/options-and-subsystems",children:"Options"})," and in ",(0,r.jsx)(s.code,{children:"Field"}),"s in your ",(0,r.jsx)(s.code,{children:"Target"}),". For example, this mechanism is how the ",(0,r.jsx)(s.code,{children:"dependencies"})," field works. This will error if the address does not exist."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'from pants.engine.addresses import AddressInput, Address\nfrom pants.engine.rules import Get, rule\n\n@rule\nasync def example(...) -> Foo:\n    address = await Get(\n        Address,\n        AddressInput,\n        AddressInput.parse("project/util:tgt", description_of_origin="my custom rule"),\n    )\n'})}),"\n",(0,r.jsxs)(s.p,{children:["Given an ",(0,r.jsx)(s.code,{children:"Address"}),", there are two ways to find its corresponding ",(0,r.jsx)(s.code,{children:"Target"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'from pants.engine.addresses import AddressInput, Address, Addresses\nfrom pants.engine.rules import Get, rule\nfrom pants.engine.target import Targets, WrappedTarget, WrappedTargetRequest\n\n@rule\nasync def example(...) -> Foo:\n    address = Address("project/util", target_name="tgt")\n\n    # Approach #1\n    wrapped_target = await Get(\n        WrappedTarget,\n        WrappedTargetRequest(address, description_of_origin="my custom rule"),\n    )\n    target = wrapped_target.target\n\n    # Approach #2\n    targets = await Get(Targets, Addresses([address]))\n    target = targets[0]\n'})}),"\n",(0,r.jsxs)(s.h2,{id:"the-dependencies-field",children:["The ",(0,r.jsx)(s.code,{children:"Dependencies"})," field"]}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"Dependencies"})," field is an ",(0,r.jsx)(s.code,{children:"AsyncField"}),", which means that you must use the engine to hydrate its values, rather than using ",(0,r.jsx)(s.code,{children:"Dependencies.value"})," like normal."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from pants.engine.target import Dependencies, DependenciesRequest, Targets\nfrom pants.engine.rules import Get, rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    direct_deps = await Get(Targets, DependenciesRequest(target.get(Dependencies)))\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"DependenciesRequest"})," takes a single argument: ",(0,r.jsx)(s.code,{children:"field: Dependencies"}),". The return type ",(0,r.jsx)(s.code,{children:"Targets"})," is a ",(0,r.jsx)(s.code,{children:"Collection"})," of individual ",(0,r.jsx)(s.code,{children:"Target"})," objects corresponding to each direct dependency of the original target."]}),"\n",(0,r.jsxs)(s.p,{children:["If you only need the addresses of a target's direct dependencies, you can use ",(0,r.jsx)(s.code,{children:"Get(Addresses, DependenciesRequest(target.get(Dependencies))"})," instead. (",(0,r.jsx)(s.code,{children:"Addresses"})," is defined in ",(0,r.jsx)(s.code,{children:"pants.engine.addresses"}),".)"]}),"\n",(0,r.jsxs)(s.h3,{id:"transitive-dependencies-with-transitivetargets",children:["Transitive dependencies with ",(0,r.jsx)(s.code,{children:"TransitiveTargets"})]}),"\n",(0,r.jsxs)(s.p,{children:["If you need the transitive dependencies of a target\u2014meaning both the direct dependencies and those dependencies' dependencies\u2014use ",(0,r.jsx)(s.code,{children:"Get(TransitiveDependencies, TransitiveTargetsRequest)"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from pants.engine.target import TransitiveTargets, TransitiveTargetsRequest\nfrom pants.engine.rules import Get, rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    transitive_targets = await Get(TransitiveTargets, TransitiveTargetsRequest([target.address]))\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"TransitiveTargetsRequest"})," takes an iterable of ",(0,r.jsx)(s.code,{children:"Address"}),"es."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"TransitiveTargets"})," has two fields: ",(0,r.jsx)(s.code,{children:"roots: tuple[Target, ...]"})," and ",(0,r.jsx)(s.code,{children:"dependencies: tuple[Target, ...]"}),". ",(0,r.jsx)(s.code,{children:"roots"})," stores the original input targets, and ",(0,r.jsx)(s.code,{children:"dependencies"})," stores the transitive dependencies of those roots. ",(0,r.jsx)(s.code,{children:"TransitiveTargets"})," also has a property ",(0,r.jsx)(s.code,{children:"closure: FrozenOrderedSet[Target]"})," which merges the roots and dependencies."]}),"\n",(0,r.jsx)(s.h3,{id:"dependencies-like-fields",children:"Dependencies-like fields"}),"\n",(0,r.jsxs)(s.p,{children:["You may want to have a field on your target that's like the normal ",(0,r.jsx)(s.code,{children:"dependencies"})," field, but you do something special with it. For example, Pants's ",(0,r.jsx)(s.a,{href:"https://github.com/pantsbuild/pants/blob/969c8dcba6eda0c939918b3bc5157ca45099b4d1/src/python/pants/core/target_types.py#L231-L257",children:"archive"})," target type has the fields ",(0,r.jsx)(s.code,{children:"files"})," and ",(0,r.jsx)(s.code,{children:"packages"}),", rather than ",(0,r.jsx)(s.code,{children:"dependencies"}),", and it has special logic on those fields like running the equivalent of ",(0,r.jsx)(s.code,{children:"pants package"})," on the ",(0,r.jsx)(s.code,{children:"packages"})," field."]}),"\n",(0,r.jsxs)(s.p,{children:["Instead of subclassing ",(0,r.jsx)(s.code,{children:"Dependencies"}),", you can subclass ",(0,r.jsx)(s.code,{children:"SpecialCasedDependencies"})," from ",(0,r.jsx)(s.code,{children:"pants.engine.target"}),". You must set the ",(0,r.jsx)(s.code,{children:"alias"})," class property to the field's name."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'from pants.engine.target import SpecialCasedDependencies, Target\n\nclass PackagesField(SpecialCasedDependencies):\n    alias = "packages"\n\nclass MyTarget(Target):\n    alias = "my_tgt"\n    core_fields = (..., PackagesField)\n'})}),"\n",(0,r.jsxs)(s.p,{children:["Then, to resolve the addresses, you can use ",(0,r.jsx)(s.code,{children:"UnparsedAddressInputs"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from pants.engine.addresses import Addresses, UnparsedAddressInputs\nfrom pants.engine.target import Targets\nfrom pants.engine.rules import Get, rule\n\n@rule\nasync def demo(...) -> Foo:\n    addresses = await Get(\n        Addresses,\n        UnparsedAddressInputs,\n        my_tgt[MyField].to_unparsed_address_inputs()\n    )\n    # Or, use this:\n    targets = await Get(\n        Targets,\n        UnparsedAddressInputs,\n        my_tgt[MyField].to_unparsed_address_inputs()\n    )\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Pants will include your special-cased dependencies with ",(0,r.jsx)(s.code,{children:"pants dependencies"}),", ",(0,r.jsx)(s.code,{children:"pants dependents"}),", and ",(0,r.jsx)(s.code,{children:"pants --changed-since"}),", but the dependencies will not show up when using ",(0,r.jsx)(s.code,{children:"await Get(Addresses, DependenciesRequest)"}),"."]}),"\n",(0,r.jsx)(s.h2,{id:"sourcesfield",children:(0,r.jsx)(s.code,{children:"SourcesField"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"SourceField"})," is an ",(0,r.jsx)(s.code,{children:"AsyncField"}),", which means that you must use the engine to hydrate its values, rather than using ",(0,r.jsx)(s.code,{children:"Sources.value"})," like normal."]}),"\n",(0,r.jsxs)(s.p,{children:["Some Pants targets like ",(0,r.jsx)(s.code,{children:"python_test"})," have the field ",(0,r.jsx)(s.code,{children:"source: str"}),", whereas others like ",(0,r.jsx)(s.code,{children:"go_package"})," have the field ",(0,r.jsx)(s.code,{children:"sources: list[str]"}),". These are represented by the fields ",(0,r.jsx)(s.code,{children:"SingleSourceField"})," and ",(0,r.jsx)(s.code,{children:"MultipleSourcesField"}),". When you're defining a new target type, you should choose which of these to subclass. However, when operating over sources generically in your ",(0,r.jsx)(s.code,{children:"@rules"}),", you can use the common base class ",(0,r.jsx)(s.code,{children:"SourcesField"})," so that your rule works with both formats."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from pants.engine.target import HydratedSources, HydrateSourcesRequest, SourcesField\nfrom pants.engine.rules import Get, rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    sources = await Get(HydratedSources, HydrateSourcesRequest(target[SourcesField]))\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"HydrateSourcesRequest"})," expects a ",(0,r.jsx)(s.code,{children:"SourcesField"})," object. This can be a subclass, such as ",(0,r.jsx)(s.code,{children:"PythonSourceField"})," or ",(0,r.jsx)(s.code,{children:"GoPackageSourcesField"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"HydratedSources"})," has a field called ",(0,r.jsx)(s.code,{children:"snapshot: Snapshot"}),", which allows you to see what files were resolved by calling ",(0,r.jsx)(s.code,{children:"hydrated_sources.snapshot.files"})," and to use the resulting ",(0,r.jsx)(s.a,{href:"/2.28/docs/writing-plugins/the-rules-api/file-system",children:(0,r.jsx)(s.code,{children:"Digest"})})," in your plugin with ",(0,r.jsx)(s.code,{children:"hydrated_sources.snapshot.digest"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["Typically, you will want to use the higher-level ",(0,r.jsx)(s.code,{children:"Get(SourceFiles, SourceFilesRequest)"})," utility instead of ",(0,r.jsx)(s.code,{children:"Get(HydrateSources, HydrateSourcesRequest)"}),". This allows you to ergonomically hydrate multiple ",(0,r.jsx)(s.code,{children:"SourcesField"}),"s objects in the same call, resulting in a single merged snapshot of all the input source fields."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from pants.core.util_rules.source_files import SourceFiles, SourceFilesRequest\nfrom pants.engine.target import SourcesField\nfrom pants.engine.rules import Get, rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    sources = await Get(SourceFiles, SourceFilesRequest([tgt1[SourcesField], tgt2[SourcesField]]))\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"SourceFilesRequest"})," expects an iterable of ",(0,r.jsx)(s.code,{children:"SourcesField"})," objects. ",(0,r.jsx)(s.code,{children:"SourceFiles"})," has a field ",(0,r.jsx)(s.code,{children:"snapshot: Snapshot"})," with the merged snapshot of all resolved input sources fields."]}),"\n",(0,r.jsxs)(s.p,{children:["To convert a list of target addresses to existing source file names, you can request ",(0,r.jsx)(s.code,{children:"HydratedSources"})," for every input target:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from itertools import chain\nfrom pants.engine.addresses import Addresses\nfrom pants.engine.collection import DeduplicatedCollection\nfrom pants.engine.rules import Get, MultiGet, rule\nfrom pants.engine.target import (HydratedSources, HydrateSourcesRequest, SourcesField, UnexpandedTargets)\n\n\nclass ProjectSources(DeduplicatedCollection[str]):\n    pass\n\n\n@rule\nasync def addresses_to_source_files(addresses: Addresses) -> ProjectSources:\n    targets = await Get(UnexpandedTargets, Addresses, addresses)\n    all_sources = await MultiGet(Get(HydratedSources, HydrateSourcesRequest(tgt.get(SourcesField))) for tgt in targets)\n    return ProjectSources(chain.from_iterable(sources.snapshot.files for sources in all_sources))\n"})}),"\n",(0,r.jsx)(s.p,{children:"This is often useful when you need to pass target addresses to commands that are not Pants goals and would not\nbe able to interpret them properly."}),"\n",(0,r.jsx)(s.h3,{id:"enabling-codegen",children:"Enabling codegen"}),"\n",(0,r.jsxs)(s.p,{children:["If you want your plugin to work with code generation, you must set the argument ",(0,r.jsx)(s.code,{children:"enable_codegen=True"}),", along with ",(0,r.jsx)(s.code,{children:"for_sources_types"})," with the types of ",(0,r.jsx)(s.code,{children:"SourcesField"})," you're expecting."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from pants.backend.python.target_types import PythonSourceField\nfrom pants.core.target_types import ResourceSourceField\nfrom pants.engine.target import HydratedSources, HydrateSourcesRequest, SourcesField\nfrom pants.engine.rules import Get, rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    sources = await Get(\n        HydratedSources,\n        HydrateSourcesRequest(\n            target.get(SourcesField),\n            enable_codegen=True,\n            for_sources_types=(PythonSourceField, ResourceSourceField)\n        )\n    )\n"})}),"\n",(0,r.jsxs)(s.p,{children:["If the provided ",(0,r.jsx)(s.code,{children:"SourcesField"})," object is already a subclass of one of the ",(0,r.jsx)(s.code,{children:"for_sources_types"}),"\u2014or it can be generated into one of those types\u2014then the sources will be hydrated; otherwise, you'll get back a ",(0,r.jsx)(s.code,{children:"HydratedSources"})," object with an empty snapshot and the field ",(0,r.jsx)(s.code,{children:"sources_type=None"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"SourceFilesRequest"})," also accepts the ",(0,r.jsx)(s.code,{children:"enable_codegen"})," and ",(0,r.jsx)(s.code,{children:"for_source_types"})," arguments. This will filter out any inputted ",(0,r.jsx)(s.code,{children:"Sources"})," field that are not compatible with ",(0,r.jsx)(s.code,{children:"for_sources_type"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from pants.backend.python.target_types import PythonSourceField\nfrom pants.core.target_types import ResourceSourceField\nfrom pants.core.util_rules.source_files import SourceFiles, SourceFilesRequest\nfrom pants.engine.target import SourcesField\nfrom pants.engine.rules import Get, rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    sources = await Get(\n        SourceFiles,\n        SourceFilesRequest(\n            [target.get(SourcesField)],\n            enable_codegen=True,\n            for_sources_types=(PythonSourceField, ResourceSourceField)\n        )\n    )\n"})}),"\n",(0,r.jsx)(s.h3,{id:"stripping-source-roots",children:"Stripping source roots"}),"\n",(0,r.jsxs)(s.p,{children:["You may sometimes want to remove source roots from files, i.e. go from ",(0,r.jsx)(s.code,{children:"src/python/f.py"})," to ",(0,r.jsx)(s.code,{children:"f.py"}),". This can make it easier to work with tools that would otherwise be confused by the source root."]}),"\n",(0,r.jsxs)(s.p,{children:["To strip source roots, use ",(0,r.jsx)(s.code,{children:"Get(StrippedSourceFiles, SourceFiles)"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from pants.core.util_rules.source_files import SourceFiles, SourceFilesRequest\nfrom pants.core.util_rules.stripped_source_files import StrippedSourceFiles\nfrom pants.engine.rules import Get, rule\nfrom pants.engine.target import SourcesField\n\n@rule\nasync demo(...) -> Foo:\n    ...\n    unstripped_sources = await Get(SourceFiles, SourceFilesRequest([target.get(SourcesField)]))\n    stripped_sources = await Get(StrippedSourceFiles, SourceFiles, unstripped_sources)\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"StrippedSourceFiles"})," has a single field ",(0,r.jsx)(s.code,{children:"snapshot: Snapshot"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["You can also use ",(0,r.jsx)(s.code,{children:"Get(StrippedSourceFiles, SourceFilesRequest)"}),", and the engine will automatically go from ",(0,r.jsx)(s.code,{children:"SourceFilesRequest -> SourceFiles -> StrippedSourceFiles)"}),"."]}),"\n",(0,r.jsxs)(s.h2,{id:"fieldsets",children:[(0,r.jsx)(s.code,{children:"FieldSet"}),"s"]}),"\n",(0,r.jsxs)(s.p,{children:["A ",(0,r.jsx)(s.code,{children:"FieldSet"})," is a way to specify which Fields your rule needs to use in a typed way that is understood by the engine."]}),"\n",(0,r.jsxs)(s.p,{children:["Normally, your rule should simply use ",(0,r.jsx)(s.code,{children:"tgt.get()"})," and ",(0,r.jsx)(s.code,{children:"tgt.has_field()"})," instead of a ",(0,r.jsx)(s.code,{children:"FieldSet"}),". However, for several of the ",(0,r.jsx)(s.a,{href:"/2.28/docs/writing-plugins/common-plugin-tasks/",children:"Common plugin tasks"}),", you will instead need to create a ",(0,r.jsx)(s.code,{children:"FieldSet"})," so that the combination of fields you use can be represented by a type understood by the engine."]}),"\n",(0,r.jsxs)(s.p,{children:["To create a ",(0,r.jsx)(s.code,{children:"FieldSet"}),", create a new dataclass with ",(0,r.jsx)(s.code,{children:"@dataclass(frozen=True)"}),". You will sometimes directly subclass ",(0,r.jsx)(s.code,{children:"FieldSet"}),", but will often subclass something like ",(0,r.jsx)(s.code,{children:"BinaryFieldSet"})," or ",(0,r.jsx)(s.code,{children:"TestFieldSet"}),". Refer to the instructions in ",(0,r.jsx)(s.a,{href:"/2.28/docs/writing-plugins/common-plugin-tasks/",children:"Common plugin tasks"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["List every ",(0,r.jsx)(s.code,{children:"Field"})," that your plugin will use as a field of your dataclass. The type hints you specify will be used by Pants to identify what ",(0,r.jsx)(s.code,{children:"Field"}),"s to use, e.g. ",(0,r.jsx)(s.code,{children:"PythonSourceField"})," or ",(0,r.jsx)(s.code,{children:"Dependencies"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["Finally, set the class property ",(0,r.jsx)(s.code,{children:"required_fields"})," as a tuple of the ",(0,r.jsx)(s.code,{children:"Field"}),"s that your plugin requires. Pants will use this to filter out irrelevant targets that your plugin does not know how to operate on. Often, this will be the same as the ",(0,r.jsx)(s.code,{children:"Field"}),"s that you listed as dataclass fields, but it does not need to be. If a target type does not have registered one of the ",(0,r.jsx)(s.code,{children:"Field"}),"s that are in the dataclass fields, and it isn't a required ",(0,r.jsx)(s.code,{children:"Field"}),", then Pants will use a default value as if the user left it off from their BUILD file."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from dataclasses import dataclass\n\nfrom pants.engine.target import Dependencies, FieldSet\n\n@dataclass(frozen=True)\nclass ShellcheckFieldSet(FieldSet):\n    required_fields = (ShellSourceField,)\n\n    source: ShellSourceField\n    # Because this is not in `required_fields`, this `FieldSet` will still match target types\n    # that don't have a `Dependencies` field registered. If it's not registered, then a\n    # default value for `Dependencies` will be used as if the user left off the field from\n    # their BUILD file.\n    dependencies: Dependencies\n"})}),"\n",(0,r.jsxs)(s.p,{children:["In your rule, you can access your ",(0,r.jsx)(s.code,{children:"FieldSet"})," like a normal dataclass, e.g. ",(0,r.jsx)(s.code,{children:"field_set.source"})," or ",(0,r.jsx)(s.code,{children:"field_set.dependencies"}),". The object also has a field called ",(0,r.jsx)(s.code,{children:"address: Address"}),"."]})]})}function h(e={}){let{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},848193(e,s,n){n.d(s,{R:()=>d,x:()=>o});var t=n(830758);let r={},i=t.createContext(r);function d(e){let s=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(i.Provider,{value:s},e.children)}},984754(e){e.exports=JSON.parse('{"id":"docs/writing-plugins/the-rules-api/rules-and-the-target-api","title":"Rules and the Target API","description":"How to use the Target API in rules.","source":"@site/versioned_docs/version-2.28/docs/writing-plugins/the-rules-api/rules-and-the-target-api.mdx","sourceDirName":"docs/writing-plugins/the-rules-api","slug":"/docs/writing-plugins/the-rules-api/rules-and-the-target-api","permalink":"/2.28/docs/writing-plugins/the-rules-api/rules-and-the-target-api","draft":false,"unlisted":false,"editUrl":"https://github.com/pantsbuild/pants/edit/main/docs/docs/writing-plugins/the-rules-api/rules-and-the-target-api.mdx","tags":[],"version":"2.28","sidebarPosition":6,"frontMatter":{"title":"Rules and the Target API","sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"Installing tools","permalink":"/2.28/docs/writing-plugins/the-rules-api/installing-tools"},"next":{"title":"Union rules (advanced)","permalink":"/2.28/docs/writing-plugins/the-rules-api/union-rules-advanced"}}')}}]);