"use strict";(self.webpackChunkpantsbuild_org=self.webpackChunkpantsbuild_org||[]).push([["36214"],{448659(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var i=t(750777),s=t(886070),d=t(848193);let r={title:"Targets and BUILD files",sidebar_position:1},o,a={},l=[{value:"BUILD files",id:"build-files",level:2},{value:"Target addresses",id:"target-addresses",level:2},{value:"Sources",id:"sources",level:2},{value:"Dependencies and dependency inference",id:"dependencies-and-dependency-inference",level:2},{value:"Default field values",id:"default-field-values",level:2},{value:"The build graph and dependency cycles",id:"the-build-graph-and-dependency-cycles",level:2},{value:"Target granularity",id:"target-granularity",level:2}];function c(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",ul:"ul",...(0,d.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Attaching metadata to your code."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["Some goals, like ",(0,s.jsx)(n.code,{children:"count-loc"})," to count lines of code, only need information found in source files."]}),"\n",(0,s.jsx)(n.p,{children:"However, most goals require metadata about your source files. For example, to run a test, you need to know about all the transitive dependencies of that test. You may also want to set a timeout on that test."}),"\n",(0,s.jsxs)(n.p,{children:["This extra information lives in entities called ",(0,s.jsx)(n.code,{children:"targets"}),". A target is a set of metadata describing your code, usually associated with some files."]}),"\n",(0,s.jsx)(n.h2,{id:"build-files",children:"BUILD files"}),"\n",(0,s.jsxs)(n.p,{children:["Target information lives in files with the name ",(0,s.jsx)(n.code,{children:"BUILD"}),". For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",metastring:'title="helloworld/greet/BUILD"',children:"python_library(\n    name = 'greet',\n    sources = ['*.py', '!*_test.py'],\n    compatibility = \">=3.6\",\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Let's break this down:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"python_library"}),": The target's type. In this case, a library containing Python code."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name = 'greet'"}),": The name of the target, which defaults to the name of the directory but may be explicitly specified. Target names must be unique within a directory."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sources = ['*.py', '!*_test.py']"}),": The source files the target is attaching metadata to."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'compatibility = ">=3.6"'}),": Indicates that this code is compatible with Python 3.6+. Pants will use this metadata when determining which Python interpreter(s) to use."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Some target types are built-in, but most are provided by backends. For example, the ",(0,s.jsx)(n.code,{children:"python_library"})," target type is provided by the ",(0,s.jsx)(n.code,{children:"pants.backend.python"})," backend."]}),"\n",(0,s.jsxs)(n.p,{children:["All target types have a ",(0,s.jsx)(n.code,{children:"name"})," field, and almost all have ",(0,s.jsx)(n.code,{children:"sources"})," and ",(0,s.jsx)(n.code,{children:"dependencies"})," fields. Specific target types will have extra fields, which you can find out by running ",(0,s.jsx)(n.code,{children:"./pants help $target"})," to see which fields a particular target has."]}),"\n",(0,s.jsx)(n.h2,{id:"target-addresses",children:"Target addresses"}),"\n",(0,s.jsxs)(n.p,{children:["A target is identified by its address. A target address has the form ",(0,s.jsx)(n.code,{children:"path/to/directory:name"}),". For example, the target in the example above has the address ",(0,s.jsx)(n.code,{children:"helloworld/greet:greet"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Addresses can be used as command-line arguments, such as ",(0,s.jsx)(n.code,{children:"./pants fmt path/to:target"}),". This will format all files that are in the ",(0,s.jsx)(n.code,{children:"sources"})," field of ",(0,s.jsx)(n.code,{children:":target"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Addresses are also used in the ",(0,s.jsx)(n.code,{children:"dependencies"})," field to depend on other targets, as explained below."]}),"\n",(0,s.jsx)(n.p,{children:"Addresses are globally unique, which is guaranteed by the fact that target names must be unique within a directory."}),"\n",(0,s.jsx)(n.admonition,{title:"Address Abbreviation",type:"note",children:(0,s.jsxs)(n.p,{children:["If the target name is the same as the name of the directory containing it, then you can omit the target name. For example, ",(0,s.jsx)(n.code,{children:"helloworld/greet"})," is an abbreviated form of ",(0,s.jsx)(n.code,{children:"helloworld/greet:greet"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"sources",children:"Sources"}),"\n",(0,s.jsxs)(n.p,{children:["Almost all targets have a ",(0,s.jsx)(n.code,{children:"sources"})," field, which determines which source files belong to the target."]}),"\n",(0,s.jsxs)(n.p,{children:["The value of the ",(0,s.jsx)(n.code,{children:"sources"})," field is a list of names and/or glob patterns, relative to the BUILD file's directory. Sources must be in or below this directory, i.e., patterns containing ",(0,s.jsx)(n.code,{children:"../"})," are not allowed."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"!"})," prefix excludes matching files that would otherwise be included. For example, ",(0,s.jsx)(n.code,{children:"['*.py', '!exclude_*.py']"})," will include ",(0,s.jsx)(n.code,{children:"foo.py"})," but not ",(0,s.jsx)(n.code,{children:"exclude_bar.py"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"**"})," for a recursive glob, e.g. ",(0,s.jsx)(n.code,{children:"sources=['**/*.py']"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"dependencies-and-dependency-inference",children:"Dependencies and dependency inference"}),"\n",(0,s.jsxs)(n.p,{children:["Almost all targets have a ",(0,s.jsx)(n.code,{children:"dependencies"})," field, which determines the direct dependencies of the target."]}),"\n",(0,s.jsxs)(n.p,{children:["Normally, you can leave off the ",(0,s.jsx)(n.code,{children:"dependencies"})," field, thanks to ",(0,s.jsx)(n.em,{children:"dependency inference"}),". Pants will read your import statements and map those imports back to your own code and your third-party dependencies. You can run ",(0,s.jsx)(n.code,{children:"./pants dependencies path/to/file.ext"})," or ",(0,s.jsx)(n.code,{children:"./pants dependencies path/to:target"})," to see what dependencies Pants infers."]}),"\n",(0,s.jsxs)(n.p,{children:["However, dependency inference cannot infer everything. For example, dependency inference does not know how to infer dependencies on ",(0,s.jsx)(n.code,{children:"resources()"})," and ",(0,s.jsx)(n.code,{children:"files()"})," targets\u2014or on generated code (like Protobuf)\u2014so you will need to sometimes explicitly add the ",(0,s.jsx)(n.code,{children:"dependencies"})," field."]}),"\n",(0,s.jsxs)(n.p,{children:["To add a new explicit dependency, include the address to the target. This will result in all of the files from that target's ",(0,s.jsx)(n.code,{children:"sources"}),' field being included. See the below tool tip "Explicit file addresses" for how to instead use more granular dependencies, which is what dependency inference uses.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",metastring:'title="helloworld/greet/BUILD"',children:'python_library(\n    dependencies=[\n        "3rdparty/python:ansicolors",\n        "helloworld/util",  # shorthand for `helloworld/util:util`\n        "helloworld/util:json_files,\n    ],\n)\n'})}),"\n",(0,s.jsx)(n.p,{children:"You only need to declare direct dependencies; there is no need to include the dependencies of your dependencies. Pants will pull in those dependencies for you."}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.mdxAdmonitionTitle,{children:["Ignore dependencies with ",(0,s.jsx)(n.code,{children:"!"})," and ",(0,s.jsx)(n.code,{children:"!!"})]}),(0,s.jsxs)(n.p,{children:["If you don't like that Pants inferred a certain dependency, you can tell Pants to ignore it with ",(0,s.jsx)(n.code,{children:"!"}),". Run ",(0,s.jsx)(n.code,{children:"./pants dependencies"})," to find the address for the problematic dependency, then copy it into the ",(0,s.jsx)(n.code,{children:"dependencies"})," field with a ",(0,s.jsx)(n.code,{children:"!"})," prefix."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'python_library(\n    dependencies=["!3rdparty/python:numpy"],\n)\n'})}),(0,s.jsxs)(n.p,{children:["You can use the prefix ",(0,s.jsx)(n.code,{children:"!!"})," to ",(0,s.jsx)(n.em,{children:"transitively"})," exclude a dependency, meaning that even if a target's dependencies include the bad dependency, no matter what, the final result will not include the value."]}),(0,s.jsxs)(n.p,{children:["Transitive excludes can only be used in target types that conventionally are not dependend upon by other targets, such ",(0,s.jsx)(n.code,{children:"pex_binary"})," and ",(0,s.jsx)(n.code,{children:"python_tests"}),". This is meant to limit confusion, as using ",(0,s.jsx)(n.code,{children:"!!"})," in something like a ",(0,s.jsx)(n.code,{children:"python_library"})," could result in surprising behavior for everything that depends on it. If you use ",(0,s.jsx)(n.code,{children:"!!"})," when not allowed to, Pants will print a helpful error message saying where you can use it."]})]}),"\n",(0,s.jsxs)(n.admonition,{title:"Dependency inference will no-op if >2 targets refer to the same file",type:"caution",children:[(0,s.jsxs)(n.p,{children:["If more than one target includes a certain file in their ",(0,s.jsx)(n.code,{children:"sources"})," field, then Pants will not infer the dependency when that file is imported because Pants cannot safely decide which target you want to use. Instead, you will need to add an explicit dependency to the ",(0,s.jsx)(n.code,{children:"dependencies"})," field."]}),(0,s.jsxs)(n.p,{children:["(Why would you ever have >1 target for the same file? Sometimes, it's helpful to have different metadata describing the same code. For example, you might want to have a ",(0,s.jsx)(n.code,{children:"python_tests"})," target that runs with Python 2, and a ",(0,s.jsx)(n.code,{children:"python_tests"})," target that runs the same tests, but with Python 3.)"]})]}),"\n",(0,s.jsxs)(n.admonition,{title:'Explicit "file addresses"',type:"note",children:[(0,s.jsxs)(n.p,{children:["When you declare an explicit dependency, like ",(0,s.jsx)(n.code,{children:"helloworld/util:json_files"}),", you end up depending on every file in the ",(0,s.jsx)(n.code,{children:"sources"})," field of ",(0,s.jsx)(n.code,{children:":json_files"}),", even if you only use some of the files. Often, this is what you meant."]}),(0,s.jsx)(n.p,{children:'However, sometimes you want to be more granular, which results in finer-grained invalidation for caching. To do this, you can use a "file address", which tells Pants to only depend on a specific file from a certain target.'}),(0,s.jsx)(n.p,{children:"Pants's dependency inference automatically uses file addresses already, so you only need to use explicit file addresses when Pants cannot infer the dependency and you want more granular dependencies than normal target addresses."}),(0,s.jsxs)(n.p,{children:["To add an explicit file address, add the file path, followed by ",(0,s.jsx)(n.code,{children:":target_name"}),". For example, ",(0,s.jsx)(n.code,{children:"helloworld/util/f1.json:json_resources"}),". If the target name is the default name, you can leave off the ",(0,s.jsx)(n.code,{children:":target_name"})," part. If the file is in the same directory or a subdirectory, you can use a relative file path like ",(0,s.jsx)(n.code,{children:"./f1.json:json_resources"}),"."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'python_library(\n    dependencies=[\n        "helloworld/util/f1.json:json_resources",\n        "./f2.json:json_resources",  # Shorthand for "helloworld/util/f2.json:json_resources\n        "helloworld/app.py",  # Shorthand for "helloworld/app.py:helloworld"\n    ],\n)\n'})}),(0,s.jsx)(n.p,{children:"What if the file's target's BUILD file is in a different directory than that file? For example, consider this target definition:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'resources(\n  name="json_resources",\n  sources=["**/*.json"],\n)\n'})}),(0,s.jsxs)(n.p,{children:["If the file is in a subdirectory from the original target definition, use ",(0,s.jsx)(n.code,{children:"../"})," in the target_name section, e.g. ",(0,s.jsx)(n.code,{children:"helloworld/util/f1.json:../json_resources"}),"."]})]}),"\n",(0,s.jsx)(n.h2,{id:"default-field-values",children:"Default field values"}),"\n",(0,s.jsx)(n.p,{children:"To cut down on boilerplate:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A target's ",(0,s.jsx)(n.code,{children:"name"})," defaults to the name of the directory it's in."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"dependencies"})," will be inferred when possible."]}),"\n",(0,s.jsxs)(n.li,{children:["Some target types will have a sensible default for the ",(0,s.jsx)(n.code,{children:"sources"})," field.\nFor example, the default value for the ",(0,s.jsx)(n.code,{children:"sources"})," field of a ",(0,s.jsx)(n.code,{children:"python_library"})," target is ",(0,s.jsx)(n.code,{children:"['*.py', '!*_test.py', '!test_*.py', '!conftest.py']"}),". That is, \"all Python source files in this target's directory that aren't test-related\"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"So, for example, the target above might be rewritten more succinctly as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",metastring:'title="helloworld/greet/BUILD"',children:'python_library(\n    compatibility = ">=3.6",\n)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If we want to use the default ",(0,s.jsx)(n.code,{children:"compatibility"})," value, we could simply write:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",metastring:'title="helloworld/greet/BUILD"',children:"python_library()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"the-build-graph-and-dependency-cycles",children:"The build graph and dependency cycles"}),"\n",(0,s.jsxs)(n.p,{children:["The set of targets in a repo form the ",(0,s.jsx)(n.em,{children:"build graph"}),". The vertices in this graph are the targets, and the (directed) edges are the dependencies."]}),"\n",(0,s.jsx)(n.p,{children:"The build graph must not contain directed cycles, i.e., it must form a DAG (a Directed Acyclic Graph). If you do have a cycle, Pants will print an error message explaining what caused the cycle and giving suggestions for how to fix it."}),"\n",(0,s.jsx)(n.h2,{id:"target-granularity",children:"Target granularity"}),"\n",(0,s.jsx)(n.p,{children:"A target's sources can be as fine-grained as a single file, or as course-grained as an entire tree of files."}),"\n",(0,s.jsxs)(n.p,{children:["If you use dependency inference and explicit file addresses in the ",(0,s.jsx)(n.code,{children:"dependencies"})," field, then target granularity has no implications for your caching and invalidation. You can, in theory, define one ",(0,s.jsx)(n.code,{children:"python_library"})," target for your entire project, for example. (However, this usually doesn't scale well as your codebase evolves.)"]}),"\n",(0,s.jsxs)(n.p,{children:["In contrast, if you use normal target addresses in the ",(0,s.jsx)(n.code,{children:"dependencies"})," field, then target granularity does have implications for caching and invalidation. Every time you add a new dependency to a target, you end up depending on every file from the ",(0,s.jsx)(n.code,{children:"sources"})," field of the dependency, even if some of them are not used by your target. So, more granular targets will result in better caching and invalidation."]}),"\n",(0,s.jsxs)(n.p,{children:["In practice, we've found that having one library and/or one test target per-directory tends to work well. The default ",(0,s.jsx)(n.code,{children:"sources"})," values for various target types reflect this."]}),"\n",(0,s.jsx)(n.p,{children:"For example, for a Python project with tests colocated with source code, we recommend defaulting to a BUILD file like this in every directory:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'python_library()\n\npython_tests(name="tests")\n'})}),"\n",(0,s.jsx)(n.admonition,{title:"Tips on setting up initial BUILD files",type:"note",children:(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/2.0/docs/using-pants/adopting-pants-in-existing-repos",children:"Adopting Pants in an Existing Repo"})," for tips on setting up Pants, including where to add BUILD files."]})})]})}function h(e={}){let{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},848193(e,n,t){t.d(n,{R:()=>r,x:()=>o});var i=t(830758);let s={},d=i.createContext(s);function r(e){let n=i.useContext(d);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(d.Provider,{value:n},e.children)}},750777(e){e.exports=JSON.parse('{"id":"docs/using-pants/concepts/targets-and-build-files","title":"Targets and BUILD files","description":"Attaching metadata to your code.","source":"@site/versioned_docs/version-2.0/docs/using-pants/concepts/targets-and-build-files.mdx","sourceDirName":"docs/using-pants/concepts","slug":"/docs/using-pants/concepts/targets-and-build-files","permalink":"/2.0/docs/using-pants/concepts/targets-and-build-files","draft":false,"unlisted":false,"editUrl":"https://github.com/pantsbuild/pants/edit/main/docs/docs/using-pants/concepts/targets-and-build-files.mdx","tags":[],"version":"2.0","sidebarPosition":1,"frontMatter":{"title":"Targets and BUILD files","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Goals","permalink":"/2.0/docs/using-pants/concepts/goals"},"next":{"title":"Options","permalink":"/2.0/docs/using-pants/concepts/options"}}')}}]);