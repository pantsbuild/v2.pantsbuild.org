"use strict";(self.webpackChunkpantsbuild_org=self.webpackChunkpantsbuild_org||[]).push([["117774"],{509272(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>a});var i=s(877512),t=s(886070),o=s(848193);let r={title:"File system",sidebar_position:3},l,d={},a=[{value:"Core abstractions: <code>Digest</code> and <code>Snapshot</code>",id:"core-abstractions-digest-and-snapshot",level:2},{value:"<code>CreateDigest</code>: create new files",id:"createdigest-create-new-files",level:2},{value:"<code>PathGlobs</code>: read from filesystem",id:"pathglobs-read-from-filesystem",level:2},{value:"<code>DigestContents</code>: read contents of files",id:"digestcontents-read-contents-of-files",level:2},{value:"<code>DigestEntries</code>: light-weight handles to files",id:"digestentries-light-weight-handles-to-files",level:2},{value:"<code>MergeDigests</code>: merge collections of files",id:"mergedigests-merge-collections-of-files",level:2},{value:"<code>DigestSubset</code>: extract certain files from a <code>Digest</code>",id:"digestsubset-extract-certain-files-from-a-digest",level:2},{value:"<code>AddPrefix</code> and <code>RemovePrefix</code>",id:"addprefix-and-removeprefix",level:2},{value:"<code>Workspace.write_digest()</code>: save to disk",id:"workspacewrite_digest-save-to-disk",level:2},{value:"<code>DownloadFile</code>",id:"downloadfile",level:2}];function c(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"How to safely interact with the file system in your plugin."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:["It is not safe to use functions like ",(0,t.jsx)(n.code,{children:"open"})," or the non-pure operations of ",(0,t.jsx)(n.code,{children:"pathlib.Path"})," like you normally might: this will break caching because they do not hook up to Pants's file watcher."]}),"\n",(0,t.jsx)(n.p,{children:"Instead, Pants has several mechanisms to work with the file system in a safe and concurrent way."}),"\n",(0,t.jsx)(n.admonition,{title:"Missing certain file operations?",type:"caution",children:(0,t.jsxs)(n.p,{children:["If it would help you to have a certain file operation, please let us know by either opening a new ",(0,t.jsx)(n.a,{href:"https://github.com/pantsbuild/pants/issues",children:"GitHub issue"})," or by messaging us on ",(0,t.jsx)(n.a,{href:"/community/members",children:"Slack"})," in the #plugins room."]})}),"\n",(0,t.jsxs)(n.h2,{id:"core-abstractions-digest-and-snapshot",children:["Core abstractions: ",(0,t.jsx)(n.code,{children:"Digest"})," and ",(0,t.jsx)(n.code,{children:"Snapshot"})]}),"\n",(0,t.jsxs)(n.p,{children:["The core building block is a ",(0,t.jsx)(n.code,{children:"Digest"}),", which is a lightweight reference to a set of files known about by the engine."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"Digest"})," is only a reference; the files are stored in the engine's persistent ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Lightning_Memory-Mapped_Database",children:"content-addressable storage (CAS)"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"The files do not need to actually exist on disk."}),"\n",(0,t.jsxs)(n.li,{children:["Every file uses a relative path. This allows the ",(0,t.jsx)(n.code,{children:"Digest"})," to be passed around in different environments safely, such as running in a temporary directory locally or running through remote execution."]}),"\n",(0,t.jsx)(n.li,{children:"The files may be binary files and/or text files."}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"Digest"})," may refer to 0 - n files. If it's empty, the digest will be equal to ",(0,t.jsx)(n.code,{children:"pants.engine.fs.EMPTY_DIGEST"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["You will never create a ",(0,t.jsx)(n.code,{children:"Digest"})," directly in rules, only in tests. Instead, you get a ",(0,t.jsx)(n.code,{children:"Digest"})," by using ",(0,t.jsx)(n.code,{children:"CreateDigest"})," or ",(0,t.jsx)(n.code,{children:"PathGlobs"}),", or using the ",(0,t.jsx)(n.code,{children:"output_digest"})," from a ",(0,t.jsx)(n.code,{children:"Process"})," that you've run."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Most of Pants's operations with the file system either accept a ",(0,t.jsx)(n.code,{children:"Digest"})," as input or return a ",(0,t.jsx)(n.code,{children:"Digest"}),". For example, when running a ",(0,t.jsx)(n.code,{children:"Process"}),", you may provide a ",(0,t.jsx)(n.code,{children:"Digest"})," as input."]}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"Snapshot"})," composes a ",(0,t.jsx)(n.code,{children:"Digest"})," and adds the useful properties ",(0,t.jsx)(n.code,{children:"files: tuple[str, ...]"})," and ",(0,t.jsx)(n.code,{children:"dirs: tuple[str, ...]"}),", which store the sorted file names and directory names, respectively. For example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'Snapshot(\n    digest=Digest(\n        fingerprint="21bcd9fcf01cc67e9547b7d931050c1c44d668e7c0eda3b5856aa74ad640098b",\n        serialized_bytes_length=162,\n    ),\n    files=("f.txt", "grandparent/parent/c.txt"),\n    dirs=("grandparent", "grandparent/parent"),\n)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"Snapshot"})," is useful when you want to know which files a ",(0,t.jsx)(n.code,{children:"Digest"})," refers to. For example, when running a tool, you might set ",(0,t.jsx)(n.code,{children:"argv=snapshot.files"}),", and then pass ",(0,t.jsx)(n.code,{children:"snapshot.digest"})," to the ",(0,t.jsx)(n.code,{children:"Process"})," so that it has access to those files."]}),"\n",(0,t.jsxs)(n.p,{children:["Given a ",(0,t.jsx)(n.code,{children:"Digest"}),", you may use the engine to enrich it into a ",(0,t.jsx)(n.code,{children:"Snapshot"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from pants.engine.fs import Snapshot\nfrom pants.engine.intrinsics import digest_to_snapshot\nfrom pants.engine.rules import rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    snapshot: Snapshot = await digest_to_snapshot(my_digest)\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"createdigest-create-new-files",children:[(0,t.jsx)(n.code,{children:"CreateDigest"}),": create new files"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"CreateDigest"})," allows you to create a new digest with whichever files you would like, even if they do not exist on disk."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from pants.engine.fs import CreateDigest, Digest, FileContent\nfrom pants.engine.intrinsics import create_digest\nfrom pants.engine.rules import rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    digest: Digest = await create_digest(\n        CreateDigest([FileContent("f1.txt", b"hello world")])\n    )\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"CreateDigest"})," constructor expects an iterable including any of these types:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"FileContent"})," objects, which represent a file to create. It takes a ",(0,t.jsx)(n.code,{children:"path: str"})," parameter, ",(0,t.jsx)(n.code,{children:"contents: bytes"})," parameter, and optional ",(0,t.jsx)(n.code,{children:"is_executable: bool"})," parameter with a default of ",(0,t.jsx)(n.code,{children:"False"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Directory"})," objects, which can be used to create empty directories. It takes a single parameter: ",(0,t.jsx)(n.code,{children:"path: str"}),". You do not need to use this when creating a file inside a certain directory; this is only to create empty directories."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"FileEntry"})," objects, which are handles to existing files from ",(0,t.jsx)(n.code,{children:"DigestEntries"}),". Do not manually create these."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This does ",(0,t.jsx)(n.em,{children:"not"})," write the ",(0,t.jsx)(n.code,{children:"Digest"})," to the build root. Use ",(0,t.jsx)(n.code,{children:"Workspace.write_digest()"})," for that."]}),"\n",(0,t.jsxs)(n.h2,{id:"pathglobs-read-from-filesystem",children:[(0,t.jsx)(n.code,{children:"PathGlobs"}),": read from filesystem"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"PathGlobs"})," allows you to read from the local file system using globbing. That is, sets of filenames with wildcard characters."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from pants.engine.fs import Digest, PathGlobs\nfrom pants.engine.intrinsics import path_globs_to_digest\nfrom pants.engine.rules import rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    digest: Digest = await path_globs_to_digest(\n        PathGlobs(["**/*.txt", "!ignore_me.txt"])\n    )\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"All globs must be relative paths, relative to the build root."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PathGlobs"})," uses the same syntax as the ",(0,t.jsx)(n.code,{children:"sources"})," field, which is roughly Git's syntax. Use ",(0,t.jsx)(n.code,{children:"*"})," for globs over just the current working directory, ",(0,t.jsx)(n.code,{children:"**"})," for recursive globs over everything below (at any level the current working directory), and prefix with ",(0,t.jsx)(n.code,{children:"!"})," for ignores."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PathGlobs"})," will ignore all values from the global option ",(0,t.jsx)(n.code,{children:"pants_ignore"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["By default, the engine will no-op for any globs that are unmatched. If you want to instead warn or error, set ",(0,t.jsx)(n.code,{children:"glob_match_error_behavior=GlobMatchErrorBehavior.warn"})," or ",(0,t.jsx)(n.code,{children:"GlobMatchErrorBehavior.error"}),". This will require that you also set ",(0,t.jsx)(n.code,{children:"description_of_origin"}),", which is a human-friendly description of where the ",(0,t.jsx)(n.code,{children:"PathGlobs"})," is coming from so that the error message is helpful. For example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from pants.engine.fs import GlobMatchErrorBehavior, PathGlobs\n\nPathGlobs(\n    globs=[shellcheck.options.config],\n    glob_match_error_behavior=GlobMatchErrorBehavior.error,\n    description_of_origin="the option `--shellcheck-config`",\n)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If you set ",(0,t.jsx)(n.code,{children:"glob_match_error_behavior"}),", you may also want to set ",(0,t.jsx)(n.code,{children:"conjunction"}),". By default, only one glob must match. If you set ",(0,t.jsx)(n.code,{children:"conjunction=GlobExpansionConjunction.all_match"}),", then all globs must match or the engine will warn or error. For example, this would fail, even if the config file existed:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from pants.engine.fs import GlobExpansionConjunction, GlobMatchErrorBehavior, PathGlobs\n\nPathGlobs(\n    globs=[shellcheck.options.config, "does_not_exist.txt"],\n    glob_match_error_behavior=GlobMatchErrorBehavior.error,\n    conjunction=GlobExpansionConjunction.all_match,\n    description_of_origin="the option `--shellcheck-config`",\n)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If you only need to resolve the file names\u2014and don't actually need to use the file content\u2014you can use ",(0,t.jsx)(n.code,{children:"await path_globs_to_paths()"})," instead of ",(0,t.jsx)(n.code,{children:"await path_globs_to_digest()"})," or ",(0,t.jsx)(n.code,{children:"await digest_to_snapshot(**implicitly(PathGlobs(...)))"}),'. This will avoid "digesting" the files to the LMDB Store cache, as a performance optimization. The returned ',(0,t.jsx)(n.code,{children:"Paths"})," instance has two properties: ",(0,t.jsx)(n.code,{children:"files: tuple[str, ...]"})," and ",(0,t.jsx)(n.code,{children:"dirs: tuple[str, ...]"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from pants.engine.fs import PathGlobs, Paths\nfrom pants.engine.intrinsics import path_globs_to_paths\nfrom pants.engine.rules import rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    paths: Paths = await path_globs_to_paths(["**/*.txt", "!ignore_me.txt"]))\n    logger.info(paths.files)\n'})}),"\n",(0,t.jsxs)(n.h2,{id:"digestcontents-read-contents-of-files",children:[(0,t.jsx)(n.code,{children:"DigestContents"}),": read contents of files"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"DigestContents"})," allows you to get the file contents from a ",(0,t.jsx)(n.code,{children:"Digest"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from pants.engine.fs import Digest, DigestContents\nfrom pants.engine.intrinsics import path_globs_to_paths\nfrom pants.engine.rules import rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    digest_contents: DigestContents = await get_digest_contents(my_digest)\n    for file_content in digest_contents:\n        logger.info(file_content.path)\n        logger.info(file_content.content)  # This will be `bytes`.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The result will be a sequence of ",(0,t.jsx)(n.code,{children:"FileContent"})," objects, which each have a property ",(0,t.jsx)(n.code,{children:"path: str"})," and a property ",(0,t.jsx)(n.code,{children:"content: bytes"}),". You may want to call ",(0,t.jsx)(n.code,{children:"content.decode()"})," to convert to ",(0,t.jsx)(n.code,{children:"str"}),"."]}),"\n",(0,t.jsxs)(n.admonition,{type:"caution",children:[(0,t.jsxs)(n.mdxAdmonitionTitle,{children:["You may not need ",(0,t.jsx)(n.code,{children:"DigestContents"})]}),(0,t.jsxs)(n.p,{children:["Only use ",(0,t.jsx)(n.code,{children:"DigestContents"})," if you need to read and operate on the content of files directly in your rule."]}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["If you are running a ",(0,t.jsx)(n.code,{children:"Process"}),", you only need to pass the ",(0,t.jsx)(n.code,{children:"Digest"})," as input and that process will be able to read all the files in its environment. If you only need the list of files included in the digest, use ",(0,t.jsx)(n.code,{children:"get_digest_entries()"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["If you only need to manipulate the directory structure of a ",(0,t.jsx)(n.code,{children:"Digest"}),", by renaming files, use ",(0,t.jsx)(n.code,{children:"DigestEntries"})," with ",(0,t.jsx)(n.code,{children:"create_digest()"})," or use ",(0,t.jsx)(n.code,{children:"add_prefix()"})," and ",(0,t.jsx)(n.code,{children:"remove_prefix()"}),". These avoid reading the file content into memory."]}),"\n"]}),"\n"]})]}),"\n",(0,t.jsxs)(n.admonition,{type:"caution",children:[(0,t.jsxs)(n.mdxAdmonitionTitle,{children:["Does not handle empty directories in a ",(0,t.jsx)(n.code,{children:"Digest"})]}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"DigestContents"})," does not have a way to represent empty directories in a ",(0,t.jsx)(n.code,{children:"Digest"})," since it is only a sequence of ",(0,t.jsx)(n.code,{children:"FileContent"})," objects. That is, passing the ",(0,t.jsx)(n.code,{children:"FileContent"})," objects to ",(0,t.jsx)(n.code,{children:"CreateDigest"})," will not result in the original ",(0,t.jsx)(n.code,{children:"Digest"})," if there were empty directories in that original ",(0,t.jsx)(n.code,{children:"Digest"}),". Use ",(0,t.jsx)(n.code,{children:"DigestEntries"})," instead if your rule needs to handle empty directories in a ",(0,t.jsx)(n.code,{children:"Digest"}),"."]})]}),"\n",(0,t.jsxs)(n.h2,{id:"digestentries-light-weight-handles-to-files",children:[(0,t.jsx)(n.code,{children:"DigestEntries"}),": light-weight handles to files"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"DigestEntries"})," allows a rule to obtain the filenames (with content digests) and empty directories from a ",(0,t.jsx)(n.code,{children:"Digest"}),". The value of a ",(0,t.jsx)(n.code,{children:"DigestEntries"})," is a sequence of ",(0,t.jsx)(n.code,{children:"FileEntry"})," and ",(0,t.jsx)(n.code,{children:"Directory"})," objects representing files and empty directories in the ",(0,t.jsx)(n.code,{children:"Digest"}),", respectively. That sequence can be passed to ",(0,t.jsx)(n.code,{children:"CreateDigest"})," to recreate the original ",(0,t.jsx)(n.code,{children:"Digest"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["This is useful if you need to manipulate the directory structure of a ",(0,t.jsx)(n.code,{children:"Digest"})," without actually needing to bring the file contents into memory (which is what occurs if you were to use ",(0,t.jsx)(n.code,{children:"DigestContents"}),")."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from pants.engine.fs import DigestEntries, Directory, FileEntry\nfrom pants.engine.intrinsics import get_digest_entries\nfrom pants.engine.rules import rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    digest_entries: DigestEntries = await get_digest_entries(my_digest)\n    for entry in digest_entries:\n        if isinstance(entry, FileEntry):\n            logger.info(entry.path)\n            logger.info(entry.file_digest)  # This will be digest of the content.\n        elif isinstance(entry, Directory):\n            logger.info(f"Empty directory: {entry.path}")\n\n'})}),"\n",(0,t.jsxs)(n.h2,{id:"mergedigests-merge-collections-of-files",children:[(0,t.jsx)(n.code,{children:"MergeDigests"}),": merge collections of files"]}),"\n",(0,t.jsxs)(n.p,{children:["Often, you will need to provide a single ",(0,t.jsx)(n.code,{children:"Digest"})," somewhere in your plugin\u2014such as the ",(0,t.jsx)(n.code,{children:"input_digest"})," for a ",(0,t.jsx)(n.code,{children:"Process"}),"\u2014but you may have multiple ",(0,t.jsx)(n.code,{children:"Digest"}),"s that you want to use. Use ",(0,t.jsx)(n.code,{children:"MergeDigests"})," to combine them all into a single ",(0,t.jsx)(n.code,{children:"Digest"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from pants.engine.fs import Digest, MergeDigests\nfrom pants.engine.intrinsics import merge_digests\nfrom pants.engine.rules import rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    digest: Digest = await merge_digests(\n        MergeDigests([\n            downloaded_tool_digest,\n            config_file_digest,\n            source_files_snapshot.digest\n        ])\n    )\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It is okay if multiple digests include the same file, so long as they have identical content."}),"\n",(0,t.jsx)(n.li,{children:"If any digests have different content for the same file, the engine will error."}),"\n",(0,t.jsxs)(n.li,{children:["It is okay if some digests are empty. The ",(0,t.jsx)(n.code,{children:"pants.engine.fs.EMPTY_DIGEST"})," constant represents an empty digest."]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"digestsubset-extract-certain-files-from-a-digest",children:[(0,t.jsx)(n.code,{children:"DigestSubset"}),": extract certain files from a ",(0,t.jsx)(n.code,{children:"Digest"})]}),"\n",(0,t.jsxs)(n.p,{children:["To get certain files out of a ",(0,t.jsx)(n.code,{children:"Digest"}),", use ",(0,t.jsx)(n.code,{children:"DigestSubset"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from pants.engine.fs import Digest, DigestSubset, PathGlobs\nfrom pants.engine.intrinsics import digest_subset_to_digest\nfrom pants.engine.rules import rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    new_digest: Digest = await digest_subset_to_digest(\n        DigestSubset(original_digest, PathGlobs(["file1.txt"]))\n    )\n'})}),"\n",(0,t.jsxs)(n.p,{children:["See the section ",(0,t.jsx)(n.code,{children:"PathGlobs"})," for more details on how the type works."]}),"\n",(0,t.jsxs)(n.h2,{id:"addprefix-and-removeprefix",children:[(0,t.jsx)(n.code,{children:"AddPrefix"})," and ",(0,t.jsx)(n.code,{children:"RemovePrefix"})]}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"AddPrefix"})," and ",(0,t.jsx)(n.code,{children:"RemovePrefix"})," to change the paths of every file in the digest, while keeping the file contents the same."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from pants.engine.fs import AddPrefix, Digest, RemovePrefix\nfrom pants.engine.intrinsics import add_prefix, remove_prefix\nfrom pants.engine.rules import rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    added_prefix: Digest = await add_prefix(\n        AddPrefix(original_digest, "new_prefix/subdir")\n    )\n    removed_prefix: Digest = await remove_prefix(\n        RemovePrefix(added_prefix, "new_prefix/subdir")\n    )\n    assert removed_prefix == original_digest\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"RemovePrefix"})," will error if it encounters any files that do not have the requested prefix."]}),"\n",(0,t.jsxs)(n.h2,{id:"workspacewrite_digest-save-to-disk",children:[(0,t.jsx)(n.code,{children:"Workspace.write_digest()"}),": save to disk"]}),"\n",(0,t.jsxs)(n.p,{children:["To write a digest to disk in the build root, request the type ",(0,t.jsx)(n.code,{children:"Workspace"}),", then use its method ",(0,t.jsx)(n.code,{children:".write_digest()"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from pants.engine.fs import Workspace\nfrom pants.engine.rules import goal_rule\n\n@goal_rule\nasync def run_my_goal(..., workspace: Workspace) -> MyGoal:\n    ...\n    # Note that this is a regular synchronous method; we do not use `await`.\n    workspace.write_digest(digest)\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The digest will always be written to the build root; you cannot write to arbitrary locations on your machine."}),"\n",(0,t.jsxs)(n.li,{children:["You may set the optional parameter ",(0,t.jsx)(n.code,{children:"path_prefix: str"})," with a relative path."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Workspace"})," is a special type that can only be requested in ",(0,t.jsx)(n.code,{children:"@goal_rule"}),"s because it is only safe to write to disk in a ",(0,t.jsx)(n.code,{children:"@goal_rule"}),'. So, a common pattern is for "downstream" rules to return a ',(0,t.jsx)(n.code,{children:"Digest"})," with the contents they want to write to disk, and then the ",(0,t.jsx)(n.code,{children:"@goal_rule"})," aggregating all the results and writing them to disk. For example, for the ",(0,t.jsx)(n.code,{children:"fmt"})," goal, each ",(0,t.jsx)(n.code,{children:"FmtResult"})," includes a ",(0,t.jsx)(n.code,{children:"digest"})," field."]}),"\n",(0,t.jsxs)(n.p,{children:["For better performance, avoid calling ",(0,t.jsx)(n.code,{children:"workspace.write_digest"})," multiple times, such as in a ",(0,t.jsx)(n.code,{children:"for"})," loop. Instead, first, merge all the digests, then write them in a single call."]}),"\n",(0,t.jsx)(n.p,{children:"Bad:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"for digest in all_digests:\n   workspace.write_digest(digest)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Good:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"merged_digest = await merge_digests(MergeDigests(all_digests))\nworkspace.write_digest(merged_digest)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"downloadfile",children:(0,t.jsx)(n.code,{children:"DownloadFile"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"DownloadFile"})," allows you to download an asset using a ",(0,t.jsx)(n.code,{children:"GET"})," request."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from pants.engine.fs import Digest, DownloadFile, FileDigest\nfrom pants.engine.download_file import download_file\nfrom pants.engine.rules import rule\n\n@rule\nasync def demo(...) -> Foo:\n    ...\n    url = "https://github.com/pex-tool/pex/releases/download/v2.1.14/pex"\n    file_digest = FileDigest(\n        "12937da9ad5ad2c60564aa35cb4b3992ba3cc5ef7efedd44159332873da6fe46",\n        2637138\n    )\n    downloaded: Digest = await download_file(\n        DownloadFile(url, file_digest), **implicitly()\n    )\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"DownloadFile"})," expects a ",(0,t.jsx)(n.code,{children:"url: str"})," parameter pointing to a stable URL for the asset, along with an ",(0,t.jsx)(n.code,{children:"expected_digest: FileDigest"})," parameter. A ",(0,t.jsx)(n.code,{children:"FileDigest"})," is like a normal ",(0,t.jsx)(n.code,{children:"Digest"}),", but represents a single file, rather than a set of files/directories. To determine the ",(0,t.jsx)(n.code,{children:"expected_digest"}),", manually download the file, then run ",(0,t.jsx)(n.code,{children:"shasum -a 256"})," to compute the fingerprint and ",(0,t.jsx)(n.code,{children:"wc -c"})," to compute the expected length of the downloaded file in bytes."]}),"\n",(0,t.jsxs)(n.p,{children:["Often, you will want to download a pre-compiled binary for a tool. When doing this, use ",(0,t.jsx)(n.code,{children:"ExternalTool"})," instead for help with extracting the binary from the download. See ",(0,t.jsx)(n.a,{href:"/stable/docs/writing-plugins/the-rules-api/installing-tools",children:"Installing tools"}),"."]}),"\n",(0,t.jsxs)(n.admonition,{title:"HTTP requests without digests are unsafe",type:"caution",children:[(0,t.jsxs)(n.p,{children:["It is not safe to use ",(0,t.jsx)(n.code,{children:"DownloadFile"})," for mutable HTTP requests, as it will never ping the server for updates once it is cached. It is also not safe to use the ",(0,t.jsx)(n.code,{children:"requests"})," library or similar because it will not be cached safely."]}),(0,t.jsxs)(n.p,{children:["You can use a ",(0,t.jsx)(n.code,{children:"Process"})," with uniquely identifying information in its arguments to run ",(0,t.jsx)(n.code,{children:"/usr/bin/curl"}),"."]})]})]})}function h(e={}){let{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},848193(e,n,s){s.d(n,{R:()=>r,x:()=>l});var i=s(830758);let t={},o=i.createContext(t);function r(e){let n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},877512(e){e.exports=JSON.parse('{"id":"docs/writing-plugins/the-rules-api/file-system","title":"File system","description":"How to safely interact with the file system in your plugin.","source":"@site/versioned_docs/version-2.30/docs/writing-plugins/the-rules-api/file-system.mdx","sourceDirName":"docs/writing-plugins/the-rules-api","slug":"/docs/writing-plugins/the-rules-api/file-system","permalink":"/stable/docs/writing-plugins/the-rules-api/file-system","draft":false,"unlisted":false,"editUrl":"https://github.com/pantsbuild/pants/edit/main/docs/docs/writing-plugins/the-rules-api/file-system.mdx","tags":[],"version":"2.30","sidebarPosition":3,"frontMatter":{"title":"File system","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Options and subsystems","permalink":"/stable/docs/writing-plugins/the-rules-api/options-and-subsystems"},"next":{"title":"Processes","permalink":"/stable/docs/writing-plugins/the-rules-api/processes"}}')}}]);