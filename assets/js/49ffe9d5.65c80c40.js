"use strict";(self.webpackChunkpantsbuild_org=self.webpackChunkpantsbuild_org||[]).push([["327734"],{994633(e,t,n){n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});var i=n(123240),s=n(886070),a=n(848193);let r={title:"Concepts",sidebar_position:0},o,l={},d=[{value:"Targets and Fields - the core building blocks",id:"targets-and-fields---the-core-building-blocks",level:2},{value:"Definition of <em>target</em>",id:"definition-of-target",level:3},{value:"Definition of <em>field</em>",id:"definition-of-field",level:3},{value:"Target == alias + combination of fields",id:"target--alias--combination-of-fields",level:3},{value:"Fields may be reused",id:"fields-may-be-reused",level:3},{value:"A Field-Driven API",id:"a-field-driven-api",level:2},{value:"Customizing fields through subclassing",id:"customizing-fields-through-subclassing",level:2},{value:"Synthetic Targets API",id:"synthetic-targets-api",level:2},{value:"Example",id:"example",level:3},{value:"Register synthetic targets per directory or globally",id:"register-synthetic-targets-per-directory-or-globally",level:3},{value:"Adding information to pants peek output",id:"adding-information-to-pants-peek-output",level:2}];function c(e){let t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"The core concepts of Targets and Fields."}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.p,{children:["The Target API defines how you interact with targets in your plugin. For example, you would use the Target API to read the ",(0,s.jsx)(t.code,{children:"source"})," / ",(0,s.jsx)(t.code,{children:"sources"})," field of a target to know which files to run on."]}),"\n",(0,s.jsx)(t.p,{children:"The Target API can also be used to add new target types\u2014such as adding support for a new language. Additionally, the Target API can be used to extend existing target types and even declare synthetic targets as if they came from a BUILD file."}),"\n",(0,s.jsx)(t.h2,{id:"targets-and-fields---the-core-building-blocks",children:"Targets and Fields - the core building blocks"}),"\n",(0,s.jsxs)(t.h3,{id:"definition-of-target",children:["Definition of ",(0,s.jsx)(t.em,{children:"target"})]}),"\n",(0,s.jsxs)(t.p,{children:["As described in ",(0,s.jsx)(t.a,{href:"/2.21/docs/using-pants/key-concepts/targets-and-build-files",children:"Targets and BUILD files"}),", a ",(0,s.jsx)(t.em,{children:"target"})," is an ",(0,s.jsx)(t.em,{children:"addressable"})," set of metadata describing some of your code."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, this BUILD file defines a ",(0,s.jsx)(t.code,{children:"PythonTestTarget"})," target with ",(0,s.jsx)(t.code,{children:'Address("project", target_name="app_test")'}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",metastring:'title="project/BUILD"',children:'python_test(\n    name="app_test",\n    source="app_test.py",\n    timeout=120,\n)\n'})}),"\n",(0,s.jsxs)(t.h3,{id:"definition-of-field",children:["Definition of ",(0,s.jsx)(t.em,{children:"field"})]}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.em,{children:"field"})," is a single value of metadata belonging to a target, such as ",(0,s.jsx)(t.code,{children:"source"})," and ",(0,s.jsx)(t.code,{children:"timeout"})," above. (",(0,s.jsx)(t.code,{children:"name"})," is a special thing used to create the ",(0,s.jsx)(t.code,{children:"Address"}),".)"]}),"\n",(0,s.jsx)(t.p,{children:"Each field has a Python class that defines its BUILD file alias, data type, and optional settings like default values. For example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",metastring:'title="example_fields.py"',children:'from pants.engine.target import IntField\n\nclass PythonTestTimeoutField(IntField):\n    alias = "timeout"\n    default = 60\n'})}),"\n",(0,s.jsx)(t.h3,{id:"target--alias--combination-of-fields",children:"Target == alias + combination of fields"}),"\n",(0,s.jsx)(t.p,{children:"Alternatively, you can think of a target as simply an alias and a combination of fields:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",metastring:'title="plugin_target_types.py"',children:'from pants.engine.target import Dependencies, SingleSourceField, Target, Tags\n\nclass CustomTarget(Target):\n    alias = "custom_target"\n    core_fields = (SingleSourceField, Dependencies, Tags)\n'})}),"\n",(0,s.jsxs)(t.p,{children:["A target's fields should make sense together. For example, it does not make sense for a ",(0,s.jsx)(t.code,{children:"python_source"})," target to have a ",(0,s.jsx)(t.code,{children:"haskell_version"})," field."]}),"\n",(0,s.jsx)(t.p,{children:"Any unrecognized fields will cause an exception when used in a BUILD file."}),"\n",(0,s.jsx)(t.h3,{id:"fields-may-be-reused",children:"Fields may be reused"}),"\n",(0,s.jsx)(t.p,{children:"Because fields are stand-alone Python classes, the same field definition may be reused across multiple different target types."}),"\n",(0,s.jsxs)(t.p,{children:["For example, many target types have the ",(0,s.jsx)(t.code,{children:"source"})," field."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",metastring:'title="BUILD"',children:'resource(\n    name="logo",\n    source="logo.png",\n)\n\ndockerfile(\n    name="docker",\n    source="Dockerfile",\n)\n'})}),"\n",(0,s.jsxs)(t.p,{children:["This gives you reuse of code (",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Don't_repeat_yourself",children:"DRY"}),") and is important for your plugin to work with multiple different target types, as explained below."]}),"\n",(0,s.jsx)(t.h2,{id:"a-field-driven-api",children:"A Field-Driven API"}),"\n",(0,s.jsx)(t.p,{children:"Idiomatic Pants plugins do not care about specific target types; they only care that the target type has the right combination of field types that the plugin needs to operate."}),"\n",(0,s.jsxs)(t.p,{children:["For example, the Python formatter Black does not actually care whether you have a ",(0,s.jsx)(t.code,{children:"python_source"}),", ",(0,s.jsx)(t.code,{children:"python_test"}),", or ",(0,s.jsx)(t.code,{children:"custom_target"})," target; all that it cares about is that your target type has the field ",(0,s.jsx)(t.code,{children:"PythonSourceField"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Targets are only ",(0,s.jsx)(t.a,{href:"/2.21/docs/writing-plugins/the-rules-api/rules-and-the-target-api",children:"used by the Rules API"})," to get access to the underlying fields through the methods ",(0,s.jsx)(t.code,{children:".has_field()"})," and ",(0,s.jsx)(t.code,{children:".get()"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'if target.has_field(PythonSourceField):\n    print("My plugin can work on this target.")\n\ntimeout_field = target.get(PythonTestTimeoutField)\nprint(timeout_field.value)\n'})}),"\n",(0,s.jsx)(t.p,{children:"This means that when creating new target types, the fields you choose for your target will determine the functionality it has."}),"\n",(0,s.jsx)(t.h2,{id:"customizing-fields-through-subclassing",children:"Customizing fields through subclassing"}),"\n",(0,s.jsxs)(t.p,{children:["Often, you may like how a field behaves, but want to make some tweaks. For example, you may want to give a default value to the ",(0,s.jsx)(t.code,{children:"SingleSourceField"})," field."]}),"\n",(0,s.jsx)(t.p,{children:"To modify an existing field, simply subclass it."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from pants.engine.target import SingleSourceField\n\nclass DockerSourceField(SingleSourceField):\n    default = "Dockerfile"\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"Target"})," methods ",(0,s.jsx)(t.code,{children:".has_field()"})," and ",(0,s.jsx)(t.code,{children:".get()"})," understand this subclass relationship, as follows:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:">>> docker_tgt.has_field(DockerSourceField)\nTrue\n>>> docker_tgt.has_field(SingleSourceField)\nTrue\n>>> python_test_tgt.has_field(DockerSourceField)\nFalse\n>>> python_test_tgt.has_field(SingleSourceField)\nTrue\n"})}),"\n",(0,s.jsx)(t.p,{children:"This subclass mechanism is key to how the Target API behaves:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["You can use subclasses of fields\u2014along with ",(0,s.jsx)(t.code,{children:"Target.has_field()"}),"\u2014 to filter out irrelevant targets. For example, the Black formatter doesn't work with any plain ",(0,s.jsx)(t.code,{children:"SourcesField"})," field; it needs ",(0,s.jsx)(t.code,{children:"PythonSourceField"}),". The Python test runner is even more specific: it needs ",(0,s.jsx)(t.code,{children:"PythonTestSourceField"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["You can create custom fields and custom target types that still work with pre-existing functionality. For example, you can subclass ",(0,s.jsx)(t.code,{children:"PythonSourceField"})," to create ",(0,s.jsx)(t.code,{children:"DjangoSourceField"}),", and the Black formatter will still be able to operate on your target."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"synthetic-targets-api",children:"Synthetic Targets API"}),"\n",(0,s.jsx)(t.p,{children:"Normally targets are declared in BUILD files to provide metadata about the project's sources and artifacts etc. Occassionally there may be instances of project metadata that is not served well by being declared explicitly in a BUILD file, for instance if the metadata itself is inferred from other sources of information. For these cases, there is a Target API for declaring synthetic targets, that is targets that are not declared in a BUILD file on disk but instead come from a Plugin's rule."}),"\n",(0,s.jsx)(t.h3,{id:"example",children:"Example"}),"\n",(0,s.jsxs)(t.p,{children:["To declare synthetic targets from a Plugin, first subclass the ",(0,s.jsx)(t.code,{children:"SyntheticTargetsRequest"})," union type and register it as a union member with ",(0,s.jsx)(t.code,{children:"UnionRule(SyntheticTargetsRequest, SubclassedType)"}),". Secondly there needs to be a rule that takes this union member type as input and returns a ",(0,s.jsx)(t.code,{children:"SyntheticAddressMaps"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from dataclasses import dataclass\nfrom pants.engine.internals.synthetic_targets import (\n    SyntheticAddressMaps,\n    SyntheticTargetsRequest,\n)\nfrom pants.engine.internals.target_adaptor import TargetAdaptor\nfrom pants.engine.unions import UnionRule\nfrom pants.engine.rules import collect_rules, rule\n\n\n@dataclass(frozen=True)\nclass SyntheticExampleTargetsRequest(SyntheticTargetsRequest):\n    pass\n\n\n@rule\nasync def example_synthetic_targets(request: SyntheticExampleTargetsRequest) -> SyntheticAddressMaps:\n    return SyntheticAddressMaps.for_targets_request(\n        request,\n        [\n            (\n              "BUILD.synthetic-example",\n              (\n                TargetAdaptor("<target-type>", "<name>", **target_field_values),\n                ...\n              ),\n            ),\n            ...\n        ]\n    )\n\n\ndef rules():\n    return (\n        *collect_rules(),\n        UnionRule(SyntheticTargetsRequest, SyntheticExampleTargetsRequest),\n        ...\n    )\n'})}),"\n",(0,s.jsx)(t.h3,{id:"register-synthetic-targets-per-directory-or-globally",children:"Register synthetic targets per directory or globally"}),"\n",(0,s.jsx)(t.p,{children:"Depending on the source information for the synthetic targets, it may make sense to either register them with a request per directory or for all directories at once with a single request."}),"\n",(0,s.jsx)(t.p,{children:"If the source information is derived from parsing files from the project source tree, then go with the per directory request style (which also is the default mode of operation), where as if the information is known up-front without consulting the project sources or otherwise does not depend on which directory is being parsed for BUILD files, it may be more performant to return all synthetic targets in a single request."}),"\n",(0,s.jsxs)(t.p,{children:["The mode of operation is declared per union member (i.e. on the subclass of the ",(0,s.jsx)(t.code,{children:"SyntheticTargetsRequest"})," class) by providing a default value to the ",(0,s.jsx)(t.code,{children:"path"})," field:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"@dataclass(frozen=True)\nclass SyntheticExamplePerDirectoryTargetsRequest(SyntheticTargetsRequest):\n    path: str = SyntheticTargetsRequest.REQUEST_TARGETS_PER_DIRECTORY\n\n@dataclass(frozen=True)\nclass SyntheticExampleAllTargetsAtOnceRequest(SyntheticTargetsRequest):\n    path: str = SyntheticTargetsRequest.SINGLE_REQUEST_FOR_ALL_TARGETS\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Any other default value for ",(0,s.jsx)(t.code,{children:"path"})," should be considered invalid and yield undefined behaviour. (that is it may change without notice in future versions of Pants.)"]}),"\n",(0,s.jsxs)(t.p,{children:["During rule execution, the ",(0,s.jsx)(t.code,{children:"path"})," field of the ",(0,s.jsx)(t.code,{children:"request"})," instance will hold the value for the path currently being parsed in case of a per directory mode of operation otherwise it will be ",(0,s.jsx)(t.code,{children:"SyntheticTargetsRequest.SINGLE_REQUEST_FOR_ALL_TARGETS"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"adding-information-to-pants-peek-output",children:"Adding information to pants peek output"}),"\n",(0,s.jsx)(t.p,{children:"Sometimes you may have metadata for a target that cannot be encompassed by a field, e.g. if it depends on the content of a file or if it requires some rule resolution to be calculated."}),"\n",(0,s.jsxs)(t.p,{children:["You can attach this data to the output of ",(0,s.jsx)(t.code,{children:"pants peek"})," by subclassing the ",(0,s.jsx)(t.code,{children:"HasAdditionalTargetDataFieldSet"})," union type and register it as a union member with ",(0,s.jsx)(t.code,{children:"UnionRule(HasAdditionalTargetDataFieldSet, SubclassedType)"}),". Then, implement a rule that takes ",(0,s.jsx)(t.code,{children:"SubclassedType"})," as input and returns an ",(0,s.jsx)(t.code,{children:"AdditionalTargetData"})," object."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from dataclasses import dataclass\nfrom pants.backend.project_info.peek import AdditionalTargetData, HasAdditionalTargetDataFieldSet\nfrom pants.engine.unions import UnionRule\nfrom pants.engine.rules import collect_rules, rule\n\n\n@dataclass(frozen=True)\nclass MyCustomTargetFieldSet(HasAdditionalTargetDataFieldSet):\n    ...\n\n\n@rule\nasync def attach_custom_target_data(field_set: MyCustomTargetFieldSet) -> AdditionalTargetData:\n    # You can return any json-serializable type for the second field\n    return AdditionalTargetData("my_custom_target_data", {"hello": "world"})\n\n\ndef rules():\n    return (*collect_rules(), UnionRule(HasAdditionalTargetDataFieldSet, MyCustomTargetFieldSet))\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Then, if you run ",(0,s.jsx)(t.code,{children:"pants peek --include-additional-info my/custom:target"})," you will see an ",(0,s.jsx)(t.code,{children:"additional_info"})," field which will contain the following JSON object:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n    "my_custom_target_data": {\n        "hello": "world"\n    }\n}\n'})})]})}function h(e={}){let{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},848193(e,t,n){n.d(t,{R:()=>r,x:()=>o});var i=n(830758);let s={},a=i.createContext(s);function r(e){let t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}},123240(e){e.exports=JSON.parse('{"id":"docs/writing-plugins/the-target-api/concepts","title":"Concepts","description":"The core concepts of Targets and Fields.","source":"@site/versioned_docs/version-2.21/docs/writing-plugins/the-target-api/concepts.mdx","sourceDirName":"docs/writing-plugins/the-target-api","slug":"/docs/writing-plugins/the-target-api/concepts","permalink":"/2.21/docs/writing-plugins/the-target-api/concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/pantsbuild/pants/edit/main/docs/docs/writing-plugins/the-target-api/concepts.mdx","tags":[],"version":"2.21","sidebarPosition":0,"frontMatter":{"title":"Concepts","sidebar_position":0},"sidebar":"docsSidebar","previous":{"title":"The Target API","permalink":"/2.21/docs/writing-plugins/the-target-api/"},"next":{"title":"Creating new fields","permalink":"/2.21/docs/writing-plugins/the-target-api/creating-new-fields"}}')}}]);