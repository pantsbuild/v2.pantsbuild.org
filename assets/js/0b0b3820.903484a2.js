"use strict";(self.webpackChunkpantsbuild_org=self.webpackChunkpantsbuild_org||[]).push([["663157"],{503068(e,n,t){t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var s=t(130538),r=t(886070),i=t(848193),l=t(685008),a=t(637180);let o={title:"Concepts",sidebar_position:0},c,u={},d=[{value:"Rules",id:"rules",level:2},{value:"Invoking other rules in a rule body",id:"invoking-other-rules-in-a-rule-body",level:2},{value:"Explicit vs. implicit rule parameters",id:"explicit-vs-implicit-rule-parameters",level:2},{value:"Explicit parameters",id:"explicit-parameters",level:3},{value:"Implicit parameters",id:"implicit-parameters",level:3},{value:"Extra context for implicit parameters",id:"extra-context-for-implicit-parameters",level:3},{value:"Static analysis of parameter types",id:"static-analysis-of-parameter-types",level:3},{value:"Rule concurrency",id:"rule-concurrency",level:2},{value:"Recursive rules",id:"recursive-rules",level:2},{value:"Valid types",id:"valid-types",level:2},{value:"Dataclasses",id:"dataclasses",level:3},{value:"Exact type matching",id:"exact-type-matching",level:3},{value:"Type disambiguation",id:"type-disambiguation",level:3},{value:"Collections",id:"collections",level:3},{value:"<code>Collection</code>: a newtype for <code>tuple</code>",id:"collection-a-newtype-for-tuple",level:3},{value:"<code>DeduplicatedCollection</code>: a newtype for <code>FrozenOrderedSet</code>",id:"deduplicatedcollection-a-newtype-for-frozenorderedset",level:3},{value:"Registering rules in <code>register.py</code>",id:"registering-rules-in-registerpy",level:2},{value:"The rule graph",id:"the-rule-graph",level:2}];function h(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"The core concepts of the Rules API."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"rules",children:"Rules"}),"\n",(0,r.jsxs)(n.p,{children:["Plugin logic is defined in ",(0,r.jsx)(n.em,{children:"rules"}),". A rule is a pure function (or, more precisely, a pure coroutine) that maps a set of statically-declared input types to a statically-declared output type."]}),"\n",(0,r.jsxs)(n.p,{children:["Each rule is an ",(0,r.jsx)(n.code,{children:"async"})," Python function annotated with the decorator ",(0,r.jsx)(n.code,{children:"@rule"}),". A rule can take any number of parameters, each of a specific type, and returns a value of a specific type. Rule parameters and return types must be annotated with ",(0,r.jsx)(n.a,{href:"https://www.python.org/dev/peps/pep-0484/",children:"type hints"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, this rule maps ",(0,r.jsx)(n.code,{children:"(int) -> str"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from pants.engine.rules import rule\n\n@rule\nasync def int_to_str(i: int) -> str:\n    return str(i)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Rules are typically module-level functions. In some cases you can define rules in nested scopes, such as inside a class or function body. But this is useful only in specific, special cases in the Pants codebase, and you are unlikely to need to use this in practice."}),"\n",(0,r.jsxs)(n.p,{children:["Although any immutable Python type, including builtin types like ",(0,r.jsx)(n.code,{children:"int"}),", can be a parameter or a return type of a rule, in almost all cases rules will deal with values of custom Python classes. These are are typically implemented as ",(0,r.jsx)(n.a,{href:"https://docs.python.org/3/library/dataclasses.html",children:"frozen dataclasses"}),", for reasons we'll get into ",(0,r.jsx)(n.a,{href:"#dataclasses",children:"below"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Generally, a rule corresponds to a step in your build process. For example, when implementing a rule to run ",(0,r.jsx)(n.a,{href:"https://www.shellcheck.net/",children:"shellcheck"})," on a set of shell scripts, you could have a rule that maps ",(0,r.jsx)(n.code,{children:"(Target, Shellcheck) -> LintResult"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@rule\nasync def run_shellcheck(target: Target, shellcheck: Shellcheck) -> LintResult:\n    # Your logic.\n    return LintResult(stdout=..., stderr=..., exit_code=...)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this example the ",(0,r.jsx)(n.code,{children:"target"})," argument points to the set of files to check, the ",(0,r.jsx)(n.code,{children:"shellcheck"})," argument points to the ",(0,r.jsx)(n.code,{children:"shellcheck"})," binary to run, and the return value contains the result of running ",(0,r.jsx)(n.code,{children:"shellcheck"})," on those files. We will see later how the values of the rule parameters, ",(0,r.jsx)(n.code,{children:"target"})," and ",(0,r.jsx)(n.code,{children:"shellcheck"})," in this example, are provided."]}),"\n",(0,r.jsx)(n.p,{children:"Although rules are implemented as Python coroutines, they differ from regular Python async code because their execution is controlled by the Pants engine and not by a standard Python event loop."}),"\n",(0,r.jsx)(n.p,{children:"The Pants engine provides the following benefits for rule execution:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'The engine analyzes the input and output types and can "fill in the blanks" of any input parameters not explicitly provided. This is why rule signatures must have complete type annotations.'}),"\n",(0,r.jsx)(n.li,{children:"The engine invokes rules concurrently where possible, to make use of all available local and remote cores. This is why rule params and return values must be immutable."}),"\n",(0,r.jsxs)(n.li,{children:["The engine applies memoization, so that if a rule has already run with the given params, the engine will supply the output value from the in-memory cache, instead of executing the rule. This is why rules must be ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Pure_function",children:"pure"})," and why rule params and return values must be hashable."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This requirement of rule purity is worth emphasizing: a rule must yield the same output for a given set of inputs, and a rule must not directly or indirectly rely on side-effecting code like ",(0,r.jsx)(n.code,{children:"print()"}),", ",(0,r.jsx)(n.code,{children:"subprocess.run()"}),", or ",(0,r.jsx)(n.code,{children:"requests"}),". The Rules API provides alternatives that are understood by the Pants engine and which work properly with its caching and concurrency mechanisms."]}),"\n",(0,r.jsx)(n.h2,{id:"invoking-other-rules-in-a-rule-body",children:"Invoking other rules in a rule body"}),"\n",(0,r.jsx)(n.p,{children:"One obvious way for a rule to depend on values of given types is to declare input parameters of those types. However it is very common to request extra values in the rule body by explicitly calling other rules. This is useful when you want programmatic control over the inputs to those other rules, or when you want to invoke other rules conditionally."}),"\n",(0,r.jsxs)(n.p,{children:["To call a rule explicitly, you ",(0,r.jsx)(n.code,{children:"await"})," it, and pass explicit and/or implicit params to it. The following contrived example shows a couple of rule calls (note that Pants ships with real shellcheck support that is more complicated, this example is simplified for clarity):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from pants.engine.rules import rule\nfrom pants.engine.intrinsics import execute_process\nfrom pants.engine.process import (\n    ProcessResult,\n    FallibleProcessResult,\n    fallible_to_exec_result_or_raise,\n)\n\n@rule\nasync def run_shellcheck(target: Target, shellcheck: Shellcheck) -> LintResult:\n    ...\n    process_request = Process(\n        ["/bin/echo", str(target.address)],\n        description=f"Echo {target.address}",\n    )\n    # Get a process result that allows failure.\n    fallible_process_result: FallibleProcessResult = await execute_process(\n        process_request, **implicitly()\n    )\n    # Raise if the process failed, or return its info if it succeeded.\n    process_result: ProcessResult = await fallible_to_exec_result_or_raise(\n        fallible_process_result, **implicitly()\n    )\n    return LintResult(\n        stdout=process_result.stdout, stderr=process_result.stderr, exit_code=0\n    )\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The Pants engine will run your rule as straight-line Python code until it encounters the ",(0,r.jsx)(n.code,{children:"await"}),", which will yield execution back to the engine. The engine will then see if it has a memoized result for the requested rule invocation. If not, it will execute the rule to obtain such a value.  Once the engine gives back the resulting output value, control will be returned back to your Python code, until the next ",(0,r.jsx)(n.code,{children:"await"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["In this example, we could not have requested the ",(0,r.jsx)(n.code,{children:"process_result"})," as a parameter to our rule because we needed to create the ",(0,r.jsx)(n.code,{children:"Process"})," object dynamically."]}),"\n",(0,r.jsxs)(n.p,{children:["We will revisit process execution ",(0,r.jsx)(n.a,{href:"#extra-context-for-implicit-parameters",children:"below"})," and cover it in a lot more detail ",(0,r.jsx)(n.a,{href:"/prerelease/docs/writing-plugins/the-rules-api/processes",children:"here"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"explicit-vs-implicit-rule-parameters",children:"Explicit vs. implicit rule parameters"}),"\n",(0,r.jsx)(n.h3,{id:"explicit-parameters",children:"Explicit parameters"}),"\n",(0,r.jsx)(n.p,{children:"In simple cases, you can pass parameters directly to invoked rules:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from pants.engine.environment import EnvironmentName\nfrom pants.engine.fs import NativeDownloadFile\nfrom pants.engine.intrinsics import download_file, run_id, run_interactive_process_in_environment\nfrom pants.engine.process import InteractiveProcess\nfrom pants.engine.rules import rule\n...\n\n@rule\nasync def my_rule() -> MyResult:\n    # Takes no params.\n    rid = await run_id()\n\n    # Takes one param.\n    downloaded_file = await download_file(NativeDownloadFile(\n        url="https://www.google.com/robots.txt",\n        expected_digest=FileDigest(\n            "988d5eecb5b9d346bb0ca87fe76ab029be332997c79c590af858cc0c6dd6d1a4",\n            7153,\n        ))\n    )\n\n    # Takes two params.\n    interactive_process_result = await run_interactive_process_in_environment(\n        InteractiveProcess(...),\n        EnvironmentName("local")\n    )\n    ...\n'})}),"\n",(0,r.jsx)(n.admonition,{title:"Explicit rule parameters must be passed positionally",type:"caution",children:(0,r.jsx)(n.p,{children:"Explicit rule parameters must be passed as positional arguments, as in the examples above. We hope\nto support keyword arguments in the future."})}),"\n",(0,r.jsx)(n.h3,{id:"implicit-parameters",children:"Implicit parameters"}),"\n",(0,r.jsxs)(n.p,{children:["In many cases it is very useful to call rules using ",(0,r.jsx)(n.em,{children:"implicit"}),' parameters. These parameters are injected by the Pants engine instead of being provided explicitly by the caller. This is the "fill in the blanks" functionality mentioned earlier, and is part of what makes the Pants engine so powerful.']}),"\n",(0,r.jsxs)(n.p,{children:["To tell the engine to implicitly fill in any unspecified parameters, you use the ",(0,r.jsx)(n.code,{children:"**implicitly()"})," idiom:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from pants.engine.rules import implicitly, rule\n\n@rule\nasync def my_rule() -> MyResult:\n    # The engine implicitly provides the GlobalOptions param.\n    ll = await log_level(**implicitly())\n\n    # The user explicitly provides the EnvironmentVarsRequest param.\n    # The engine implicitly provides the CompleteEnvironmentVars param.\n    localization_vars = await environment_vars_subset(\n        EnvironmentVarsRequest(["LANG", "LC_ALL"]), **implicitly()\n    )\n    ...\n'})}),"\n",(0,r.jsx)(n.p,{children:"Where does Pants get the values for implicit parameters? They can be:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["From external context, such as ",(0,r.jsx)(n.a,{href:"/using-pants/key-concepts/options",children:"option values"}),", git state, or the set of targets provided on the Pants command line."]}),"\n",(0,r.jsx)(n.li,{children:"From the input parameters of the calling rule."}),"\n",(0,r.jsx)(n.li,{children:"Computed from other params by (transitively) applying suitable rules. You can think of this as a form of dependency injection via type: Pants knows the type of the implicit parameter, and can traverse a path through rule execution to go from an initial set of values, known from context, to the needed value."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Since explicit params must be provided positionally, they must be the first arguments to the rule. This means that when you write a rules, you should put the parameters expected to be passed explicitly before the parameters expected to be provided implicitly."}),"\n",(0,r.jsx)(n.h3,{id:"extra-context-for-implicit-parameters",children:"Extra context for implicit parameters"}),"\n",(0,r.jsxs)(n.p,{children:["As mentioned above, Pants can compute values for implicit parameters by transitively applying rules. In many cases the initial parameters for ",(0,r.jsx)(n.em,{children:"those"})," rules are known from external context. But in some cases we need to provide extra context from the calling rule. To do so, we pass the contextual parameters as arguments to ",(0,r.jsx)(n.code,{children:"**implicitly()"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from pants.engine.process import fallible_to_exec_result_or_raise\nfrom pants.engine.rules import implicitly, rule\n\n@rule\nasync def my_rule() -> MyResult:\n    process_result = await fallible_to_exec_result_or_raise(\n        **implicitly(\n            Process(\n                ["/bin/echo", str(target.address)],\n                description=f"Echo {target.address}",\n            )\n        )\n    )\n    ...\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In this example the ",(0,r.jsx)(n.code,{children:"fallible_to_exec_result_or_raise()"})," rule takes a ",(0,r.jsx)(n.code,{children:"FallibleProcessResult"})," and returns a ",(0,r.jsx)(n.code,{children:"ProcessResult"})," by first checking the ",(0,r.jsx)(n.code,{children:"FallibleProcessResult"})," for success and raising an exception if it failed. We saw this earlier, in the simplified shellcheck example."]}),"\n",(0,r.jsxs)(n.p,{children:["But instead of explicitly passing a ",(0,r.jsx)(n.code,{children:"FallibleProcessResult"})," as we did earlier, we now pass a ",(0,r.jsx)(n.code,{children:"Process"})," as implicit context. The Pants engine then looks at all the rules it knows about to figure out how to compute a ",(0,r.jsx)(n.code,{children:"FallibleProcessResult"})," from a ",(0,r.jsx)(n.code,{children:"Process"}),". The ",(0,r.jsx)(n.code,{children:"execute_process()"})," we encountered earlier fits the bill, and so the engine calls it on our ",(0,r.jsx)(n.code,{children:"Process"})," and passes its return value into ",(0,r.jsx)(n.code,{children:"fallible_to_exec_result_or_raise()"}),". Whereas earlier we called both rules explicitly, here we get the exact same behavior with just one call."]}),"\n",(0,r.jsxs)(n.p,{children:["In fact, since raising an exception on process failure is frequently what you want, we have an alias, ",(0,r.jsx)(n.code,{children:"execute_process_or_raise"}),", to make the code more readable when using this common shorthand idiom."]}),"\n",(0,r.jsx)(n.h3,{id:"static-analysis-of-parameter-types",children:"Static analysis of parameter types"}),"\n",(0,r.jsxs)(n.p,{children:["It's important to note that the parameter types, and the corresponding rule matching, are computed ",(0,r.jsx)(n.em,{children:"statically"}),", at engine startup time. Pants employs various static analysis heuristics to capture common cases. E.g., in the example above, the engine knows that the parameter passed to ",(0,r.jsx)(n.code,{children:"**implicitly()"})," is intended to match the formal parameter type ",(0,r.jsx)(n.code,{children:"Process"})," because it recognizes the explicit ",(0,r.jsx)(n.code,{children:"Process()"})," initializer call."]}),"\n",(0,r.jsxs)(n.p,{children:["But in some cases the parameter value will have been created earlier, and the engine can't know its type from static analysis. In such cases you must provide the type explicitly, by passing a dict to ",(0,r.jsx)(n.code,{children:"**implicitly()"})," mapping values to the formal parameter types they are intended to match:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from pants.engine.process import execute_process_or_raise\nfrom pants.engine.rules import implicitly, rule\n\n@rule\nasync def my_rule() -> MyResult:\n    process = Process(...)\n    ...\n    process_result = await execute_process_or_raise(\n        **implicitly({\n            process: Process,\n            ProductDescription("Running echo"): ProductDescription,\n        })\n    )\n    ...\n'})}),"\n",(0,r.jsxs)(n.p,{children:["As you can see above, this also allows you to pass multiple contextual params to ",(0,r.jsx)(n.code,{children:"**implicitly()"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"rule-concurrency",children:"Rule concurrency"}),"\n",(0,r.jsxs)(n.p,{children:["The engine pauses execution on each ",(0,r.jsx)(n.code,{children:"await"})," in your rule until the result is returned. This means that if you have two consecutive ",(0,r.jsx)(n.code,{children:"await"}),"s, the engine will evaluate them sequentially."]}),"\n",(0,r.jsxs)(n.p,{children:["If your rules can be executed concurrently (because nether depends on the result of the other) then you can use ",(0,r.jsx)(n.code,{children:"concurrently(...)"})," to instead get multiple results in a single ",(0,r.jsx)(n.code,{children:"await"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from pants.engine.rules import concurrently, rule\n\n@rule\nasync def lint_single_target(target: Target) -> LintResult:\n    ...\n\n@rule\nasync def lint_all(targets: Targets) -> LintResults:\n    single_results = await concurrently(\n        lint_single_target(target, **implicitly()) for target in targets\n    )\n    ...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The result of ",(0,r.jsx)(n.code,{children:"concurrently"})," is a tuple with each individual result, in the same order as the requests. You should hardly ever call ",(0,r.jsx)(n.code,{children:"await"})," in a loop - use ",(0,r.jsx)(n.code,{children:"await concurrently"})," instead."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"concurrently"})," can either take an iterable of rule calls, as above, or take multiple individual rule calls. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from pants.engine.rules import concurrently, rule\n\n@rule\nasync def my_rule() -> MyResult:\n    first_party_deps, third_party_deps = await concurrently(\n        get_first_party_deps(FirstPartyDepsRequest(...)),\n        get_third_party_deps(ThirdPartyDepsRequest(...)),\n    )\n"})}),"\n",(0,r.jsx)(n.h2,{id:"recursive-rules",children:"Recursive rules"}),"\n",(0,r.jsx)(n.p,{children:"A rule can call itself recursively:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from dataclasses import dataclass\nfrom pants.engine.rules import rule\n\n@dataclass(frozen=True)\nclass Fibonacci:\n    val: int\n\n@rule\nasync def fibonacci(n: int) -> Fibonacci:\n    if n < 2:\n        return Fibonacci(n)\n    x, y = await concurrently(fibonacci(n - 2), fibonacci(n - 1))\n    return Fibonacci(x.val + y.val)\n"})}),"\n",(0,r.jsx)(n.p,{children:"This is useful in cases such as compiling a JVM source file, which first requires compiling its direct dependencies."}),"\n",(0,r.jsx)(n.p,{children:"Rules can even be mutually recursive, that is, there can be circular calls between multiple rules. However in this case the rules must all be top-level functions in the same module. This is due to limitations of the engine's static analysis heuristics. In practice, mutual recursion between functions in different modules would create forbidden Python import cycles anyway, unless you used local imports or other unsavory workarounds."}),"\n",(0,r.jsx)(n.h2,{id:"valid-types",children:"Valid types"}),"\n",(0,r.jsxs)(n.p,{children:["Input params and output values must be hashable, and therefore must be immutable. Specifically, their types must implement ",(0,r.jsx)(n.code,{children:"__hash__()"})," and ",(0,r.jsx)(n.code,{children:"__eq__()"}),". While the engine will not validate that your type is immutable, you should be careful to ensure this so that the cache works properly."]}),"\n",(0,r.jsx)(n.h3,{id:"dataclasses",children:"Dataclasses"}),"\n",(0,r.jsxs)(n.p,{children:["Python 3's ",(0,r.jsx)(n.a,{href:"https://docs.python.org/3/library/dataclasses.html",children:"dataclasses"})," work well with the engine because:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"frozen=True"})," is set, they are immutable and hashable."]}),"\n",(0,r.jsx)(n.li,{children:"Dataclasses use type hints."}),"\n",(0,r.jsx)(n.li,{children:"Dataclasses are declarative and ergonomic."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["You are not required to use dataclasses. You can use alternatives like ",(0,r.jsx)(n.code,{children:"attrs"})," or normal Python classes with manual ",(0,r.jsx)(n.code,{children:"__hash__()"})," and ",(0,r.jsx)(n.code,{children:"__eq__()"})," implementations. However, dataclasses are convenient and idiomatic, and we encourage their use."]}),"\n",(0,r.jsxs)(n.p,{children:["You should set ",(0,r.jsx)(n.code,{children:"@dataclass(frozen=True)"})," for Python to autogenerate ",(0,r.jsx)(n.code,{children:"__hash__()"})," and to ensure that the type is immutable."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from __future__ import annotations\n\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass Name:\n    first: str\n    last: str | None\n\n@rule\nasync def demo(name: Name) -> Foo:\n    ...\n"})}),"\n",(0,r.jsxs)(n.admonition,{type:"caution",children:[(0,r.jsxs)(n.mdxAdmonitionTitle,{children:["Don't use ",(0,r.jsx)(n.code,{children:"NamedTuple"})]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"NamedTuple"})," behaves similarly to dataclasses, but it should not be used because the ",(0,r.jsx)(n.code,{children:"__eq__()"})," implementation uses structural equality, rather than the nominal equality used by the engine."]})]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsxs)(n.mdxAdmonitionTitle,{children:["Custom dataclass ",(0,r.jsx)(n.code,{children:"__init__()"})]}),(0,r.jsxs)(n.p,{children:["Sometimes, you may want to have a custom ",(0,r.jsx)(n.code,{children:"__init__()"})," constructor. For example, you may want your dataclass to store a ",(0,r.jsx)(n.code,{children:"tuple[str, ...]"}),", but for your constructor to take the more flexible ",(0,r.jsx)(n.code,{children:"Iterable[str]"})," which you then convert to an immutable tuple sequence."]}),(0,r.jsxs)(n.p,{children:["The Python docs suggest using ",(0,r.jsx)(n.code,{children:"object.__setattr__"})," to set attributes in your ",(0,r.jsx)(n.code,{children:"__init__"})," for frozen dataclasses."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Iterable\n\n@dataclass(frozen=True)\nclass Example:\n    args: tuple[str, ...]\n\n    def __init__(self, args: Iterable[str]) -> None:\n        object.__setattr__(self, "args", tuple(args))\n'})})]}),"\n",(0,r.jsx)(n.h3,{id:"exact-type-matching",children:"Exact type matching"}),"\n",(0,r.jsx)(n.p,{children:'Recall that type annotations are used by the engine at runtime to "fill in the blanks" of implicit parameters. This is an unsual use of type hints, which are normally for the benefit of build time type checking by tools such as MyPy.'}),"\n",(0,r.jsxs)(n.p,{children:["Unlike type checkers, the engine uses ",(0,r.jsx)(n.em,{children:"exact"})," type matches and does not consider subtyping. Even if ",(0,r.jsx)(n.code,{children:"Truck"})," subclasses ",(0,r.jsx)(n.code,{children:"Vehicle"}),", the engine will view these types as completely unrelated when deciding how to fill in implicit parameters. The engine has a different way of expressing polymorphism, namely ",(0,r.jsx)(n.a,{href:"/prerelease/docs/writing-plugins/the-rules-api/union-rules-advanced",children:"unions"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"type-disambiguation",children:"Type disambiguation"}),"\n",(0,r.jsxs)(n.p,{children:['To disambiguate between different uses of the same type, you will usually want to "newtype" the types that you use. For example, instead of using the builtin ',(0,r.jsx)(n.code,{children:"str"})," or ",(0,r.jsx)(n.code,{children:"int"})," to represent a name or age you can define new classes that nominally extend them:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Name(str):\n    pass\n\nclass Age(int):\n    pass\n"})}),"\n",(0,r.jsx)(n.h3,{id:"collections",children:"Collections"}),"\n",(0,r.jsx)(n.p,{children:"Fields of input params and output values may be collections, but you must use the following types:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"tuple"})," instead of ",(0,r.jsx)(n.code,{children:"list"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"pants.util.frozendict.FrozenDict"})," instead of ",(0,r.jsx)(n.code,{children:"dict"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"pants.util.ordered_set.FrozenOrderedSet"})," instead of ",(0,r.jsx)(n.code,{children:"set"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The type annotations for parameters and return values must be just a type name. For example, a rule cannot return ",(0,r.jsx)(n.code,{children:"Foo | None"}),", or take ",(0,r.jsx)(n.code,{children:"tuple[Foo, ...]"})," as a parameter."]}),"\n",(0,r.jsxs)(n.h3,{id:"collection-a-newtype-for-tuple",children:[(0,r.jsx)(n.code,{children:"Collection"}),": a newtype for ",(0,r.jsx)(n.code,{children:"tuple"})]}),"\n",(0,r.jsxs)(n.p,{children:["If you want a rule to use a homogenous sequence, you can use ",(0,r.jsx)(n.code,{children:"pants.engine.collection.Collection"}),' to "newtype" a tuple. This will behave the same as a tuple, but will have a distinct type.']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from pants.engine.collection import Collection\n\n@dataclass(frozen=True)\nclass LintResult:\n    stdout: str\n    stderr: str\n    exit_code: int\n\n\nclass LintResults(Collection[LintResult]):\n    pass\n\n\n@rule\nasync def demo(results: LintResults) -> Foo:\n    for result in results:\n        print(result.stdout)\n    ...\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"deduplicatedcollection-a-newtype-for-frozenorderedset",children:[(0,r.jsx)(n.code,{children:"DeduplicatedCollection"}),": a newtype for ",(0,r.jsx)(n.code,{children:"FrozenOrderedSet"})]}),"\n",(0,r.jsxs)(n.p,{children:["If you want a rule to use a homogenous set, you can use ",(0,r.jsx)(n.code,{children:"pants.engine.collection.DeduplicatedCollection"})," to newtype a ",(0,r.jsx)(n.code,{children:"FrozenOrderedSet"}),". This will behave the same as a ",(0,r.jsx)(n.code,{children:"FrozenOrderedSet"}),", but will have a distinct type."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from pants.engine.collection import DeduplicatedCollection\n\nclass RequirementStrings(DeduplicatedCollection[str]):\n    sort_input = True\n\n\n@rule\nasync def demo(requirements: RequirementStrings) -> Foo:\n    for requirement in requirements:\n        print(requirement)\n    ...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Setting the class property ",(0,r.jsx)(n.code,{children:"sort_input"})," to ",(0,r.jsx)(n.code,{children:"True"})," will often result in more cache hits, at the expense of time spent sorting."]}),"\n",(0,r.jsxs)(n.h2,{id:"registering-rules-in-registerpy",children:["Registering rules in ",(0,r.jsx)(n.code,{children:"register.py"})]}),"\n",(0,r.jsxs)(n.p,{children:["To register a new rule, use the ",(0,r.jsx)(n.code,{children:"rules()"})," hook in your ",(0,r.jsxs)(n.a,{href:"/prerelease/docs/writing-plugins/overview",children:[(0,r.jsx)(n.code,{children:"register.py"})," file"]}),". This function expects a list of functions annotated with ",(0,r.jsx)(n.code,{children:"@rule"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'title="pants-plugins/plugin1/register.py"',children:"def rules():\n    return [rule1, rule2]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Conventionally, each file will have a function called ",(0,r.jsx)(n.code,{children:"rules()"})," and then ",(0,r.jsx)(n.code,{children:"register.py"})," will re-export them. This is meant to make imports more organized. Within each file, you can use ",(0,r.jsx)(n.code,{children:"collect_rules()"})," to automatically find the rules in the file."]}),"\n",(0,r.jsxs)(l.A,{groupId:"code-examples",children:[(0,r.jsx)(a.A,{value:"pants-plugins/fortran/register.py",label:"pants-plugins/fortran/register.py",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'tab={"label":"pants-plugins/fortran/register.py"}',children:"from fortran import fmt, test\n\ndef rules():\n    return [*fmt.rules(), *test.rules()]\n"})})}),(0,r.jsx)(a.A,{value:"pants-plugins/fortran/fmt.py",label:"pants-plugins/fortran/fmt.py",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'tab={"label":"pants-plugins/fortran/fmt.py"}',children:"from pants.engine.rules import collect_rules, rule\n\n@rule\nasync def setup_formatter(...) -> Formatter:\n    ...\n\n@rule\nasync def fmt_fortran(...) -> FormatResult:\n    ...\n\ndef rules():\n    return collect_rules()\n"})})}),(0,r.jsx)(a.A,{value:"pants-plugins/fortran/test.py",label:"pants-plugins/fortran/test.py",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'tab={"label":"pants-plugins/fortran/test.py"}',children:"from pants.engine.rules import collect_rules, rule\n\n@rule\nasync def run_fotran_test(...) -> TestResult:\n    ...\n\ndef rules():\n    return collect_rules()\n"})})})]}),"\n",(0,r.jsx)(n.h2,{id:"the-rule-graph",children:"The rule graph"}),"\n",(0,r.jsxs)(n.p,{children:["As we mentioned above, at startup the Pants engine performs static analysis on the registered rules. The resulting analysis is represented as a ",(0,r.jsx)(n.em,{children:"rule graph"}),".  This is a directed graph where the nodes represent ",(0,r.jsx)(n.em,{children:"queries"}),", rules or ",(0,r.jsx)(n.em,{children:"params"}),", and the edges represent data dependencies."]}),"\n",(0,r.jsxs)(n.p,{children:["The queries are the roots of the graph - graph traversals always start at a query. When the user runs a Pants command, the engine looks for a special type of rule, annotated with ",(0,r.jsx)(n.code,{children:"@goal_rule"}),", that implements the respective goal. For example, ",(0,r.jsx)(n.code,{children:"pants list"})," triggers the ",(0,r.jsx)(n.code,{children:"list"})," Goal rule, which in turn represents a query into the rule graph."]}),"\n",(0,r.jsx)(n.p,{children:"The params are the leaves of the graph - they represent initial data that is provided from context, such as option values or command line arguments. All other intermediate types and the final goal type are computed from these params by traversing the graph and executing rules along the way."}),"\n",(0,r.jsxs)(n.p,{children:["To view the graph for a goal, see: ",(0,r.jsx)(n.a,{href:"/prerelease/docs/writing-plugins/the-rules-api/tips-and-debugging#debugging-visualize-the-rule-graph",children:"Visualize the rule graph"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"If the engine cannot find a path, or if there is ambiguity due to multiple possible paths, rule graph construction will fail."}),"\n",(0,r.jsxs)(n.admonition,{title:"Rule graph errors can be confusing",type:"caution",children:[(0,r.jsxs)(n.p,{children:["We know that rule graph errors can be intimidating and confusing to understand. We are planning to improve them. In the meantime, please do not hesitate to ask for help on ",(0,r.jsx)(n.a,{href:"/community/getting-help",children:"Slack"}),"."]}),(0,r.jsxs)(n.p,{children:["Also see ",(0,r.jsx)(n.a,{href:"/prerelease/docs/writing-plugins/the-rules-api/tips-and-debugging#debugging-rule-graph-issues",children:"Tips and debugging"})," for some tips for how to approach these errors."]})]})]})}function p(e={}){let{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},753348(e,n,t){t.d(n,{A:()=>s});let s={tabItem:"tabItem_mHvh"}},618264(e,n,t){t.d(n,{A:()=>s});let s={tabList:"tabList_sFbf",tabItem:"tabItem_UVfV"}},637180(e,n,t){t.d(n,{A:()=>l});var s=t(886070);t(830758);var r=t(313526),i=t(753348);function l({children:e,hidden:n,className:t}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,r.A)(i.A.tabItem,t),hidden:n,children:e})}},685008(e,n,t){t.d(n,{A:()=>m});var s=t(886070),r=t(830758),i=t(313526),l=t(911212),a=t(274875),o=t(106632),c=t(189223),u=t(618264);function d({className:e,block:n,selectedValue:t,selectValue:r,tabValues:l}){let o=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.a_)(),d=e=>{let n=e.currentTarget,s=l[o.indexOf(n)].value;s!==t&&(c(n),r(s))},h=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{let t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{let t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1]}}n?.focus()};return(0,s.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":n},e),children:l.map(({value:e,label:n,attributes:r})=>(0,s.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{o.push(e)},onKeyDown:h,onClick:d,...r,className:(0,i.A)("tabs__item",u.A.tabItem,r?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function h({lazy:e,children:n,selectedValue:t}){let l=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){let e=l.find(e=>e.props.value===t);return e?(0,r.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,s.jsx)("div",{className:"margin-top--md",children:l.map((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function p(e){let n=(0,o.u)(e);return(0,s.jsxs)("div",{className:(0,i.A)(l.G.tabs.container,"tabs-container",u.A.tabList),children:[(0,s.jsx)(d,{...n,...e}),(0,s.jsx)(h,{...n,...e})]})}function m(e){let n=(0,c.A)();return(0,s.jsx)(p,{...e,children:(0,o.v)(e.children)},String(n))}},106632(e,n,t){t.d(n,{u:()=>d,v:()=>c});var s=t(830758),r=t(325557),i=t(363717),l=t(125740),a=t(574229),o=t(270367);function c(e){return s.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,s.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function u({value:e,tabValues:n}){return n.some(n=>n.value===e)}function d(e){let n,{defaultValue:t,queryString:d=!1,groupId:h}=e,p=function(e){let{values:n,children:t}=e;return(0,s.useMemo)(()=>{let e=n??c(t).map(({props:{value:e,label:n,attributes:t,default:s}})=>({value:e,label:n,attributes:t,default:s})),s=(0,a.XI)(e,(e,n)=>e.value===n.value);if(s.length>0)throw Error(`Docusaurus error: Duplicate values "${s.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`);return e},[n,t])}(e),[m,x]=(0,s.useState)(()=>(function({defaultValue:e,tabValues:n}){if(0===n.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!u({value:e,tabValues:n}))throw Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}let t=n.find(e=>e.default)??n[0];if(!t)throw Error("Unexpected error: 0 tabValues");return t.value})({defaultValue:t,tabValues:p})),[y,f]=function({queryString:e=!1,groupId:n}){let t=(0,r.W6)(),i=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,l.aZ)(i),(0,s.useCallback)(e=>{if(!i)return;let n=new URLSearchParams(t.location.search);n.set(i,e),t.replace({...t.location,search:n.toString()})},[i,t])]}({queryString:d,groupId:h}),[g,j]=function({groupId:e}){let n=e?`docusaurus.tab.${e}`:null,[t,r]=(0,o.Dv)(n);return[t,(0,s.useCallback)(e=>{n&&r.set(e)},[n,r])]}({groupId:h}),v=u({value:n=y??g,tabValues:p})?n:null;return(0,i.A)(()=>{v&&x(v)},[v]),{selectedValue:m,selectValue:(0,s.useCallback)(e=>{if(!u({value:e,tabValues:p}))throw Error(`Can't select invalid tab value=${e}`);x(e),f(e),j(e)},[f,j,p]),tabValues:p}}},848193(e,n,t){t.d(n,{R:()=>l,x:()=>a});var s=t(830758);let r={},i=s.createContext(r);function l(e){let n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(i.Provider,{value:n},e.children)}},130538(e){e.exports=JSON.parse('{"id":"docs/writing-plugins/the-rules-api/concepts","title":"Concepts","description":"The core concepts of the Rules API.","source":"@site/versioned_docs/version-2.31/docs/writing-plugins/the-rules-api/concepts.mdx","sourceDirName":"docs/writing-plugins/the-rules-api","slug":"/docs/writing-plugins/the-rules-api/concepts","permalink":"/prerelease/docs/writing-plugins/the-rules-api/concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/pantsbuild/pants/edit/main/docs/docs/writing-plugins/the-rules-api/concepts.mdx","tags":[],"version":"2.31","sidebarPosition":0,"frontMatter":{"title":"Concepts","sidebar_position":0},"sidebar":"docsSidebar","previous":{"title":"The Rules API","permalink":"/prerelease/docs/writing-plugins/the-rules-api/"},"next":{"title":"Goal rules","permalink":"/prerelease/docs/writing-plugins/the-rules-api/goal-rules"}}')}}]);