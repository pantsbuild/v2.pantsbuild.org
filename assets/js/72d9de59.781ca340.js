"use strict";(self.webpackChunkpantsbuild_org=self.webpackChunkpantsbuild_org||[]).push([["552043"],{641433(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>u});var s=t(659698),r=t(886070),o=t(848193),i=t(685008),a=t(637180);let l={title:"Advanced plugin concepts",sidebar_position:2},c,d={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Adding a custom <code>source</code> field",id:"adding-a-custom-source-field",level:3},{value:"Ensuring a version follows a semver convention",id:"ensuring-a-version-follows-a-semver-convention",level:3},{value:"Exploring caching",id:"exploring-caching",level:3},{value:"Showing output as JSON",id:"showing-output-as-json",level:3},{value:"Automating generation of <code>project_version</code> targets",id:"automating-generation-of-project_version-targets",level:3},{value:"Running system tools",id:"running-system-tools",level:3},{value:"Putting it all together",id:"putting-it-all-together",level:3}];function h(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Learning advanced concepts for writing plugins."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(n.p,{children:["In this tutorial, we continue from where we've left in the ",(0,r.jsx)(n.a,{href:"/2.18/docs/tutorials-coming-soon/create-a-new-goal",children:"previous tutorial"}),". Having now a complete goal with a custom target, we are ready to make certain improvements and learn more advanced concepts that you would likely find useful when working on your own plugins."]}),"\n",(0,r.jsxs)(n.h3,{id:"adding-a-custom-source-field",children:["Adding a custom ",(0,r.jsx)(n.code,{children:"source"})," field"]}),"\n",(0,r.jsxs)(n.p,{children:["In the first tutorial, to keep things simple, we used the default ",(0,r.jsx)(n.code,{children:"SingleSourceField"})," class for our ",(0,r.jsx)(n.code,{children:"source"})," field where we provided the path to the ",(0,r.jsx)(n.code,{children:"VERSION"})," file. We could have added ",(0,r.jsx)(n.a,{href:"/2.18/docs/writing-plugins/the-target-api/creating-new-fields",children:"a custom field"})," to provide a file path, however, when using the ",(0,r.jsx)(n.code,{children:"source"})," field, you get a few features for free such as setting the ",(0,r.jsx)(n.code,{children:"default"})," value and ",(0,r.jsx)(n.code,{children:"expected_file_extensions"}),". Furthermore, with the ",(0,r.jsx)(n.code,{children:"source"})," field, thanks to the ",(0,r.jsx)(n.a,{href:"/2.18/reference/global-options#unmatched_build_file_globs",children:(0,r.jsx)(n.code,{children:"unmatched_build_file_globs"})})," option, you won't need to provide custom logic to handle errors when path globs do not expand to any files in your repository."]}),"\n",(0,r.jsxs)(n.p,{children:["Let's modify our ",(0,r.jsx)(n.code,{children:"myapp/BUILD"})," file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'version_file(\n    name="main-project-version",\n    source="non-existing-file",\n)\n'})}),"\n",(0,r.jsxs)(n.p,{children:["and run the ",(0,r.jsx)(n.code,{children:"project-version"})," goal:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"$ pants project-version myapp:\n...\n[WARN] Unmatched glob from myapp:main-project-version's `source` field: \"myapp/non-existing-file\"\n[ERROR] 1 Exception encountered:\n\n  InvalidFieldException: The 'source' field in target myapp:main-project-version must have 1 file, but it had 0 files.\n...\n"})}),"\n",(0,r.jsx)(n.p,{children:"It is possible to adjust how Pants handle unmatched globs to prevent this type of issue:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'$ PANTS_UNMATCHED_BUILD_FILE_GLOBS=error pants project-version myapp:\n[ERROR] 1 Exception encountered:\n  Exception: Unmatched glob from myapp:main-project-version\'s `source` field: "myapp/non-existing-file"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["We would likely want to use the same name for the version file (",(0,r.jsx)(n.code,{children:"VERSION"}),") throughout the repo for consistency, so we should probably set a default value for the target to reduce the amount of boilerplate in the ",(0,r.jsx)(n.code,{children:"BUILD"})," files. To change a default value, we have to subclass the original field. Visit ",(0,r.jsx)(n.a,{href:"/2.18/docs/writing-plugins/the-target-api/concepts#customizing-fields-through-subclassing",children:"customizing fields through subclassing"})," to learn more."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'title="pants-plugins/project_version/target_types.py"',children:'from pants.engine.target import COMMON_TARGET_FIELDS, SingleSourceField, Target\n\nclass ProjectVersionSourceField(SingleSourceField):\n    help = "Path to the file with the project version."\n    default = "VERSION"\n    required = False\n\nclass ProjectVersionTarget(Target):\n    alias = "version_file"\n    core_fields = (*COMMON_TARGET_FIELDS, ProjectVersionSourceField)\n    help = "A project version target representing the VERSION file."\n'})}),"\n",(0,r.jsxs)(n.p,{children:["You may have noticed that we have decided to override the ",(0,r.jsx)(n.code,{children:"help"})," property to show more relevant information than the default help message:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"$ pants help version_file\n`version_file` target\n---------------------\n\nA project version target representing the VERSION file.\n\nActivated by project_version\nValid fields:\n\n...\nsource\n    type: str | None\n    default: 'VERSION'\n\n    Path to the file with the project version.\n...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Having a dedicated source field will let us filter the targets based on the fact that they have a ",(0,r.jsx)(n.code,{children:"ProjectVersionSourceField"})," field instead of checking what their alias is. This means we can refactor how we collect the relevant targets from:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"targets = [tgt for tgt in targets if tgt.alias == ProjectVersionTarget.alias]\n"})}),"\n",(0,r.jsx)(n.p,{children:"to"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"targets = [tgt for tgt in targets if tgt.has_field(ProjectVersionSourceField)]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Using own classes via subclassing will also help with refactoring if you decide to deprecate the target alias in order to rename it. In a more advanced scenario, other plugins may import the ",(0,r.jsx)(n.code,{children:"ProjectVersionSourceField"})," field and use it in their own custom targets, so that ",(0,r.jsx)(n.code,{children:"project-version"})," specific behavior would still apply to those targets as well."]}),"\n",(0,r.jsx)(n.h3,{id:"ensuring-a-version-follows-a-semver-convention",children:"Ensuring a version follows a semver convention"}),"\n",(0,r.jsxs)(n.p,{children:["With the current implementation, we have simply returned the contents of the file as is. We may want to add some validation, for instance, to check that a version string follows a semver convention. Let's learn how to ",(0,r.jsx)(n.a,{href:"/2.18/docs/writing-plugins/overview#thirdparty-dependencies",children:"bring a 3rd party Python package"}),", namely, ",(0,r.jsx)(n.a,{href:"https://pypi.org/project/packaging/",children:"packaging"}),", into our plugin to do that!"]}),"\n",(0,r.jsxs)(n.p,{children:["To start depending on the ",(0,r.jsx)(n.code,{children:"packaging"})," package in our in-repo plugin, we must extend the ",(0,r.jsx)(n.code,{children:"pants.toml"})," file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:'[GLOBAL]\nplugins = ["packaging==22.0"]\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Now, let's raise an exception if it isn't possible to construct an instance of the ",(0,r.jsx)(n.code,{children:"Version"})," class:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from packaging.version import Version, InvalidVersion\nfrom project_version.target_types import ProjectVersionTarget, ProjectVersionSourceField\n\nclass InvalidProjectVersionString(ValueError):\n    pass\n\n@goal_rule\nasync def goal_show_project_version(targets: Targets) -> ProjectVersionGoal:\n    targets = [tgt for tgt in targets if tgt.has_field(ProjectVersionSourceField)]\n    results = await MultiGet(\n        Get(ProjectVersionFileView, ProjectVersionTarget, target) for target in targets\n    )\n    for result in results:\n        try:\n           _ = Version(result.version)\n        except InvalidVersion:\n            raise InvalidProjectVersionString(f\"Invalid version string '{result.version}' from '{result.path}'\")\n    ...\n"})}),"\n",(0,r.jsx)(n.p,{children:"To test this behavior, let's set a bogus version and see our goal in action!"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"$ cat myapp/VERSION\nx.y.z\n\n$ pants project-version myapp:\n[ERROR] 1 Exception encountered:\n\n    InvalidProjectVersionString: Invalid version string 'x.y.z' from 'myapp/VERSION'\n"})}),"\n",(0,r.jsx)(n.h3,{id:"exploring-caching",children:"Exploring caching"}),"\n",(0,r.jsxs)(n.p,{children:["When you have run the goal a few times, you may have noticed that sometimes the command takes a few seconds to complete, and sometimes it completes immediately. If that's the case, then you have just seen ",(0,r.jsx)(n.a,{href:"/2.18/docs/writing-plugins/the-rules-api/tips-and-debugging#fyi-caching-semantics",children:"Pants caching"})," working! Because we use Pants engine to read the ",(0,r.jsx)(n.code,{children:"VERSION"})," file, it copies it into the cache. Pants knows that when the command is re-run, if there are no changes to the Python source code or the ",(0,r.jsx)(n.code,{children:"VERSION"})," file, there's no need to re-run the code because the result is guaranteed to stay the same."]}),"\n",(0,r.jsxs)(n.p,{children:["If your plugin uses 3rd party Python packages dependencies, it can be worth checking whether the package has any side effects such as reading from the filesystem since this won't let you take full advantage of the Pants engine's caching mechanism. Keep in mind that the commands you run via Pants may be cancelled or retried any number of times, so ideally any side effects should be ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Idempotence",children:"idempotent"}),". That is, it should not matter if it is run once or several times."]}),"\n",(0,r.jsxs)(n.p,{children:["You can confirm that cache is being used by adding ",(0,r.jsx)(n.a,{href:"/2.18/docs/writing-plugins/the-rules-api/logging-and-dynamic-output",children:"log statements"}),". When run for the first time, the logging messages will show up; on subsequent runs, they won't because the code of the rules won't be executed."]}),"\n",(0,r.jsx)(n.h3,{id:"showing-output-as-json",children:"Showing output as JSON"}),"\n",(0,r.jsxs)(n.p,{children:["We have so far shown the version string as part of the ",(0,r.jsx)(n.code,{children:"ProjectVersionFileView"})," class:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"$ pants project-version myapp:\nProjectVersionFileView(path='myapp/VERSION', version='0.0.1')\n"})}),"\n",(0,r.jsxs)(n.p,{children:["To be able to pipe the output of our command, it may make sense to emit the format in a parseable structure instead of plain text. Pants goals come with lots of options that can adjust their behavior, and this is true for custom goals as well. Let's ",(0,r.jsx)(n.a,{href:"/2.18/docs/writing-plugins/the-rules-api/options-and-subsystems",children:"add a new option"})," for our goal, so that the version information would be shown as a JSON object."]}),"\n",(0,r.jsx)(n.p,{children:"Adding a new option is trivial and is done in the subsystem:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class ProjectVersionSubsystem(GoalSubsystem):\n    name = "project-version"\n    help = "Show representation of the project version from the `VERSION` file."\n\n    as_json = BoolOption(\n        default=False,\n        help="Show project version information as JSON.",\n    )\n'})}),"\n",(0,r.jsx)(n.p,{children:"To use a subsystem in the goal rule (where we show the version in the console), we need to request it as a parameter:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import json\n\n@goal_rule\nasync def goal_show_project_version(\n    console: Console, project_version_subsystem: ProjectVersionSubsystem\n) -> ProjectVersionGoal:\n    ...\n    if project_version_subsystem.as_json:\n        console.print_stdout(json.dumps(dataclasses.asdict(result)))\n    else:\n        console.print_stdout(str(result))\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Let's run our goal with the new ",(0,r.jsx)(n.code,{children:"--as-json"})," flag:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'$ pants project-version --as-json myapp: | jq\n{\n  "path": "myapp/VERSION",\n  "version": "0.0.1"\n}\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"automating-generation-of-project_version-targets",children:["Automating generation of ",(0,r.jsx)(n.code,{children:"project_version"})," targets"]}),"\n",(0,r.jsxs)(n.p,{children:["Pants provides a way to automate generation of standard targets using the ",(0,r.jsx)(n.a,{href:"/2.18/reference/goals/tailor",children:(0,r.jsx)(n.code,{children:"tailor"})})," goal. If a monorepository has many projects, each containing a ",(0,r.jsx)(n.code,{children:"VERSION"})," file, it might be useful to generate ",(0,r.jsx)(n.code,{children:"version_file"})," targets in every directory where the relevant files are found. This is what Pants does, for instance, when Docker backend is enabled, and you have ",(0,r.jsx)(n.code,{children:"Dockerfile"})," files in the codebase. To make this work for our use case, however, we need to introduce the ",(0,r.jsx)(n.code,{children:"tailor"})," goal to the ",(0,r.jsx)(n.code,{children:"VERSION"})," files."]}),"\n",(0,r.jsxs)(n.p,{children:["We've reached the moment when the documentation won't be of help: there are no instructions on how to extend the ",(0,r.jsx)(n.code,{children:"tailor"})," goal. In a situation like this, it may be worth exploring the Pants codebase to see how this was done in other plugins that are part of Pants. Once you find a piece of code that looks like it does what you want, you can copy it and tweak it to better suit your needs. For our use case, the code used in ",(0,r.jsx)(n.a,{href:"https://github.com/pantsbuild/pants/blob/672ca1d662c76f2567e432347deee8949c14d35d/src/python/pants/backend/cc/goals/tailor.py",children:"generation of C++ source targets"})," may get handy. After making a few changes, we have a new rule we can place in a new file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'title="pants-plugins/project_version/tailor.py"',children:'from __future__ import annotations\n\nfrom dataclasses import dataclass\n\nfrom pants.core.goals.tailor import (\n    AllOwnedSources,\n    PutativeTarget,\n    PutativeTargets,\n    PutativeTargetsRequest,\n)\nfrom pants.util.dirutil import group_by_dir\nfrom pants.engine.fs import PathGlobs, Paths\nfrom pants.engine.internals.selectors import Get\nfrom pants.engine.rules import collect_rules, rule\nfrom pants.engine.unions import UnionRule\nfrom project_version.target_types import ProjectVersionTarget\n\n\n@dataclass(frozen=True)\nclass PutativeProjectVersionTargetsRequest(PutativeTargetsRequest):\n    pass\n\n\n@rule(desc="Determine candidate project_version targets to create")\nasync def find_putative_targets(\n    req: PutativeProjectVersionTargetsRequest,\n    all_owned_sources: AllOwnedSources,\n) -> PutativeTargets:\n    all_project_version_files = await Get(Paths, PathGlobs, req.path_globs("VERSION"))\n    unowned_project_version_files = set(all_project_version_files.files) - set(\n        all_owned_sources\n    )\n    classified_unowned_project_version_files = {\n        ProjectVersionTarget: unowned_project_version_files\n    }\n\n    putative_targets = []\n    for tgt_type, paths in classified_unowned_project_version_files.items():\n        for dirname, filenames in group_by_dir(paths).items():\n            putative_targets.append(\n                PutativeTarget.for_target_type(\n                    ProjectVersionTarget,\n                    path=dirname,\n                    name="project-version-file",\n                    triggering_sources=sorted(filenames),\n                )\n            )\n\n    return PutativeTargets(putative_targets)\n\n\ndef rules():\n    return [\n        *collect_rules(),\n        UnionRule(PutativeTargetsRequest, PutativeProjectVersionTargetsRequest),\n    ]\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In this file, we use an advanced feature of Pants, ",(0,r.jsx)(n.a,{href:"/2.18/docs/writing-plugins/the-rules-api/union-rules-advanced",children:"union rules"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def rules():\n    return [\n        *collect_rules(),\n        UnionRule(PutativeTargetsRequest, PutativeProjectVersionTargetsRequest),\n    ]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When the ",(0,r.jsx)(n.code,{children:"tailor"})," goal is run, the build graph is analyzed to see when ",(0,r.jsx)(n.code,{children:"PutativeTargetsRequest"})," is needed, i.e. to find out if there are any files (yet unknown to Pants) that look like they could potentially be made targets. For instance, if there is a ",(0,r.jsx)(n.code,{children:"requirements.txt"})," file, a ",(0,r.jsx)(n.code,{children:"python_requirement"})," target is created and when there is a Python ",(0,r.jsx)(n.code,{children:"test_"})," module, a ",(0,r.jsx)(n.code,{children:"python_test"})," target is created. To be able to customize the ",(0,r.jsx)(n.code,{children:"tailor"}),' goal (to allow generation of custom targets), we need to "extend" the build graph. That is, we ask Pants to also run our rule when searching for files that maybe should have a target created.']}),"\n",(0,r.jsx)(n.p,{children:"We also have to make sure that the new rule is collected:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'title="pants-plugins/project_version/register.py"',children:"...\ndef rules():\n    return [*project_version_rules.rules(), *tailor_rules.rules()]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Let's remove existing ",(0,r.jsx)(n.code,{children:"version_file"})," target from the ",(0,r.jsx)(n.code,{children:"myapp/BUILD"})," file and run the ",(0,r.jsx)(n.code,{children:"tailor"})," goal:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"$ pants tailor ::\nCreated myapp/BUILD:\n  - Add version_file target project-version-file\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you have multiple projects, being able to generate the targets automatically may save time. You would also likely want to run the ",(0,r.jsx)(n.code,{children:"tailor"})," goal in the check mode to confirm that new projects created have a ",(0,r.jsx)(n.code,{children:"version_file"})," target. Remove the ",(0,r.jsx)(n.code,{children:"version_file"})," target from the ",(0,r.jsx)(n.code,{children:"myapp/BUILD"})," file and re-run the ",(0,r.jsx)(n.code,{children:"tailor"})," goal:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"$ pants tailor --check ::\nWould create myapp/BUILD:\n  - Add version_file target project-version-file\n\nTo fix `tailor` failures, run `pants tailor`.\n"})}),"\n",(0,r.jsx)(n.h3,{id:"running-system-tools",children:"Running system tools"}),"\n",(0,r.jsxs)(n.p,{children:["Pants lets you ",(0,r.jsx)(n.a,{href:"/2.18/docs/writing-plugins/the-rules-api/installing-tools",children:"run system applications"})," your plugin may need. For our use case, we can assume that Git is installed and can be run from the ",(0,r.jsx)(n.code,{children:"/usr/bin/git"}),". If there's a ",(0,r.jsx)(n.code,{children:"VERSION"})," file in the root of the repository representing the final artifact version (in case of a monolith), we could use Git to confirm that the version string matches the latest tag the repository was tagged with."]}),"\n",(0,r.jsx)(n.p,{children:"We can create a new rule:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class GitTagVersion(str):\n    pass\n\n@rule\nasync def get_git_repo_version(buildroot: BuildRoot) -> GitTagVersion:\n    git_paths = await Get(\n        BinaryPaths,\n        BinaryPathRequest(\n            binary_name="git",\n            search_path=["/usr/bin", "/bin"],\n        ),\n    )\n    git_bin = git_paths.first_path\n    if git_bin is None:\n        raise OSError("Could not find \'git\'.")\n    git_describe = await Get(\n        ProcessResult,\n        Process(\n            argv=[git_bin.path, "-C", buildroot.path, "describe", "--tags"],\n            description="git describe --tags",\n        ),\n    )\n    return GitTagVersion(git_describe.stdout.decode().strip())\n'})}),"\n",(0,r.jsx)(n.p,{children:"and then use this rule in the main goal rule:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class ProjectVersionGitTagMismatch(ValueError):\n    pass\n\n@goal_rule\nasync def goal_show_project_version(...) -> ProjectVersionGoal:\n    ...\n    git_repo_version = await Get(GitTagVersion)\n    ...\n    if git_repo_version != result.version:\n        raise ProjectVersionGitTagMismatch(\n            f\"Project version string '{result.version}' from '{result.path}' \"\n            f\"doesn't match latest Git tag '{git_repo_version}'\"\n        )\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Let's modify our ",(0,r.jsx)(n.code,{children:"VERSION"})," file to have a version different from what we have tagged our repository with:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"$ git tag 0.0.1\n$ git describe --tags\n0.0.1\n$ cat myapp/VERSION\n0.0.2\n\n$ pants project-version --as-json myapp:\n12:40:17.02 [INFO] Initializing scheduler...\n12:40:17.14 [INFO] Scheduler initialized.\n12:40:17.18 [ERROR] 1 Exception encountered:\n\n  ProjectVersionGitTagMismatch: Project version string '0.0.2' from 'myapp/VERSION' doesn't match latest Git tag '0.0.1'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now, let's tag our repository with another tag and update our ",(0,r.jsx)(n.code,{children:"VERSION"})," file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'$ git tag --delete 0.0.1\nDeleted tag \'0.0.1\' (was 006f320)\n$ git tag 0.0.2\n$ git describe --tags\n0.0.2\n$ cat myapp/VERSION\n0.0.1\n\n$ pants project-version --as-json myapp:\n{"path": "myapp/VERSION", "version": "0.0.1"}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Pants is happy, but clearly something is wrong as our Git tag version doesn't match the ",(0,r.jsx)(n.code,{children:"myapp/VERSION"})," version! If you update your ",(0,r.jsx)(n.code,{children:"myapp/VERSION"})," with another version, say, ",(0,r.jsx)(n.code,{children:"0.0.3"}),", we get an error, but this time, the shown Git tag is wrong:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"$ cat myapp/VERSION\n0.0.3\n\n$ pants project-version --as-json myapp:\n[ERROR] 1 Exception encountered:\n\n  ProjectVersionGitTagMismatch: Project version string '0.0.3' from 'myapp/VERSION' doesn't match latest Git tag '0.0.1'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This happens because of how the Pants cache works. Modifying our repository tags doesn't qualify for the changes that should invalidate the cache. It is not safe to ",(0,r.jsxs)(n.a,{href:"/2.18/docs/writing-plugins/the-rules-api/processes",children:["cache the ",(0,r.jsx)(n.code,{children:"Process"})," runs"]})," and since we know that Git will access the repository (that is outside the sandbox), we should change its cacheability using the ",(0,r.jsx)(n.code,{children:"ProcessCacheScope"})," parameter so that our Git call would run once per run of Pants."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'git_describe = await Get(\n    ProcessResult,\n    Process(\n        argv=[git_bin.path, "-C", buildroot.path, "describe", "--tags"],\n        description="git describe --tags",\n        cache_scope=ProcessCacheScope.PER_SESSION,\n    ),\n)\n'})}),"\n",(0,r.jsx)(n.p,{children:"Let's add another option so that we can control whether Git tag should be retrieved:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class ProjectVersionSubsystem(GoalSubsystem):\n    name = "project-version"\n    help = "Show representation of the project version from the `VERSION` file."\n\n    ...\n    match_git = BoolOption(\n        default=False,\n        help="Check Git tag of the repository matches the project version.",\n    )\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Keep in mind that once you've declared ",(0,r.jsx)(n.a,{href:"/2.18/docs/using-pants/key-concepts/options#setting-options",children:"custom options in the plugin's subsystem"}),", they can be set in the ",(0,r.jsx)(n.code,{children:"pants.toml"})," file just like any standard Pants options."]}),"\n",(0,r.jsxs)(n.p,{children:["If you know that your Git tag may be different from the project version stored in the ",(0,r.jsx)(n.code,{children:"VERSION"})," file and that you would always want the output to be in the JSON format, you can set these options in the ",(0,r.jsx)(n.code,{children:"pants.toml"})," file for visibility (and to avoid setting them via command line flags):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:"[project-version]\nas_json = true\nmatch_git = false\n"})}),"\n",(0,r.jsx)(n.h3,{id:"putting-it-all-together",children:"Putting it all together"}),"\n",(0,r.jsx)(n.p,{children:"We have now extended the plugin with extra functionality:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'$ pants project-version myapp:\n[INFO] Initializing scheduler...\n[INFO] Scheduler initialized.\n{"path": "myapp/VERSION", "version": "0.0.1"}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Let's get all of this code in one place:"}),"\n",(0,r.jsxs)(i.A,{groupId:"code-examples",children:[(0,r.jsx)(a.A,{value:"pants-plugins/project_version/register.py",label:"pants-plugins/project_version/register.py",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'tab={"label":"pants-plugins/project_version/register.py"}',children:"from typing import Iterable\n\nimport project_version.rules as project_version_rules\nimport project_version.tailor as tailor_rules\nfrom pants.engine.target import Target\nfrom project_version.target_types import ProjectVersionTarget\n\n\ndef target_types() -> Iterable[type[Target]]:\n    return [ProjectVersionTarget]\n\n\ndef rules():\n    return [*project_version_rules.rules(), *tailor_rules.rules()]\n"})})}),(0,r.jsx)(a.A,{value:"pants-plugins/project_version/rules.py",label:"pants-plugins/project_version/rules.py",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'tab={"label":"pants-plugins/project_version/rules.py"}',children:'import dataclasses\nimport json\nfrom dataclasses import dataclass\n\nfrom packaging.version import InvalidVersion, Version\nfrom pants.base.build_root import BuildRoot\nfrom pants.core.util_rules.system_binaries import BinaryPathRequest, BinaryPaths\nfrom pants.engine.console import Console\nfrom pants.engine.fs import DigestContents\nfrom pants.engine.goal import Goal, GoalSubsystem\nfrom pants.engine.internals.native_engine import Digest\nfrom pants.engine.internals.selectors import Get, MultiGet\nfrom pants.engine.process import Process, ProcessCacheScope, ProcessResult\nfrom pants.engine.rules import collect_rules, goal_rule, rule\nfrom pants.engine.target import (\n    HydratedSources,\n    HydrateSourcesRequest,\n    SourcesField,\n    Targets,\n)\nfrom pants.option.option_types import BoolOption\nfrom project_version.target_types import ProjectVersionSourceField, ProjectVersionTarget\n\n\n@dataclass(frozen=True)\nclass ProjectVersionFileView:\n    path: str\n    version: str\n\n\n@rule\nasync def get_project_version_file_view(\n    target: ProjectVersionTarget,\n) -> ProjectVersionFileView:\n    sources = await Get(HydratedSources, HydrateSourcesRequest(target[SourcesField]))\n    digest_contents = await Get(DigestContents, Digest, sources.snapshot.digest)\n    file_content = digest_contents[0]\n    return ProjectVersionFileView(\n        path=file_content.path, version=file_content.content.decode("utf-8").strip()\n    )\n\n\nclass ProjectVersionSubsystem(GoalSubsystem):\n    name = "project-version"\n    help = "Show representation of the project version from the `VERSION` file."\n\n    as_json = BoolOption(\n        default=False,\n        help="Show project version information as JSON.",\n    )\n    match_git = BoolOption(\n        default=False,\n        help="Check Git tag of the repository matches the project version.",\n    )\n\n\nclass ProjectVersionGoal(Goal):\n    subsystem_cls = ProjectVersionSubsystem\n    environment_behavior = Goal.EnvironmentBehavior.LOCAL_ONLY\n\n\nclass InvalidProjectVersionString(ValueError):\n    pass\n\n\nclass ProjectVersionGitTagMismatch(ValueError):\n    pass\n\n\nclass GitTagVersion(str):\n    pass\n\n\n@goal_rule\nasync def goal_show_project_version(\n    console: Console,\n    targets: Targets,\n    project_version_subsystem: ProjectVersionSubsystem,\n) -> ProjectVersionGoal:\n    targets = [tgt for tgt in targets if tgt.has_field(ProjectVersionSourceField)]\n    results = await MultiGet(\n        Get(ProjectVersionFileView, ProjectVersionTarget, target) for target in targets\n    )\n    if project_version_subsystem.match_git:\n        git_repo_version = await Get(GitTagVersion)\n\n    for result in results:\n        try:\n            _ = Version(result.version)\n        except InvalidVersion:\n            raise InvalidProjectVersionString(\n                f"Invalid version string \'{result.version}\' from \'{result.path}\'"\n            )\n        if project_version_subsystem.match_git:\n            if git_repo_version != result.version:\n                raise ProjectVersionGitTagMismatch(\n                    f"Project version string \'{result.version}\' from \'{result.path}\' "\n                    f"doesn\'t match latest Git tag \'{git_repo_version}\'"\n                )\n\n        if project_version_subsystem.as_json:\n            console.print_stdout(json.dumps(dataclasses.asdict(result)))\n        else:\n            console.print_stdout(str(result))\n\n    return ProjectVersionGoal(exit_code=0)\n\n\n@rule\nasync def get_git_repo_version() -> GitTagVersion:\n    git_paths = await Get(\n        BinaryPaths,\n        BinaryPathRequest(\n            binary_name="git",\n            search_path=["/usr/bin", "/bin"],\n        ),\n    )\n    git_bin = git_paths.first_path\n    if git_bin is None:\n        raise OSError("Could not find \'git\'.")\n    git_describe = await Get(\n        ProcessResult,\n        Process(\n            argv=[git_bin.path, "-C", buildroot.path, "describe", "--tags"],\n            description="git describe --tags",\n            cache_scope=ProcessCacheScope.PER_SESSION,\n        ),\n    )\n    return GitTagVersion(git_describe.stdout.decode().strip())\n\n\ndef rules():\n    return collect_rules()\n'})})}),(0,r.jsx)(a.A,{value:"pants-plugins/project_version/tailor.py",label:"pants-plugins/project_version/tailor.py",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'tab={"label":"pants-plugins/project_version/tailor.py"}',children:'from __future__ import annotations\n\nfrom dataclasses import dataclass\n\nfrom pants.core.goals.tailor import (\n    AllOwnedSources,\n    PutativeTarget,\n    PutativeTargets,\n    PutativeTargetsRequest,\n)\nfrom pants.engine.fs import PathGlobs, Paths\nfrom pants.engine.internals.selectors import Get\nfrom pants.engine.rules import collect_rules, rule\nfrom pants.engine.unions import UnionRule\nfrom pants.util.dirutil import group_by_dir\nfrom project_version.target_types import ProjectVersionTarget\n\n\n@dataclass(frozen=True)\nclass PutativeProjectVersionTargetsRequest(PutativeTargetsRequest):\n    pass\n\n\n@rule(desc="Determine candidate version_file targets to create")\nasync def find_putative_targets(\n    req: PutativeProjectVersionTargetsRequest,\n    all_owned_sources: AllOwnedSources,\n) -> PutativeTargets:\n    all_project_version_files = await Get(Paths, PathGlobs, req.path_globs("VERSION"))\n    unowned_project_version_files = set(all_project_version_files.files) - set(\n        all_owned_sources\n    )\n    classified_unowned_project_version_files = {\n        ProjectVersionTarget: unowned_project_version_files\n    }\n\n    putative_targets = []\n    for tgt_type, paths in classified_unowned_project_version_files.items():\n        for dirname, filenames in group_by_dir(paths).items():\n            putative_targets.append(\n                PutativeTarget.for_target_type(\n                    ProjectVersionTarget,\n                    path=dirname,\n                    name="project-version-file",\n                    triggering_sources=sorted(filenames),\n                )\n            )\n\n    return PutativeTargets(putative_targets)\n\n\ndef rules():\n    return [\n        *collect_rules(),\n        UnionRule(PutativeTargetsRequest, PutativeProjectVersionTargetsRequest),\n    ]\n'})})}),(0,r.jsx)(a.A,{value:"pants-plugins/project_version/target_types.py",label:"pants-plugins/project_version/target_types.py",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'tab={"label":"pants-plugins/project_version/target_types.py"}',children:'from pants.engine.target import COMMON_TARGET_FIELDS, SingleSourceField, Target\n\n\nclass ProjectVersionSourceField(SingleSourceField):\n    alias = "source"\n    help = "Path to the file with the project version."\n    default = "VERSION"\n    required = False\n\n\nclass ProjectVersionTarget(Target):\n    alias = "version_file"\n    core_fields = (*COMMON_TARGET_FIELDS, ProjectVersionSourceField)\n    help = "A project version target representing the VERSION file."\n'})})})]}),"\n",(0,r.jsx)(n.p,{children:"There are a few more things left to do, for example, we haven't written any tests yet. This is what we'll do in the next tutorial!"})]})}function p(e={}){let{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},753348(e,n,t){t.d(n,{A:()=>s});let s={tabItem:"tabItem_mHvh"}},618264(e,n,t){t.d(n,{A:()=>s});let s={tabList:"tabList_sFbf",tabItem:"tabItem_UVfV"}},637180(e,n,t){t.d(n,{A:()=>i});var s=t(886070);t(830758);var r=t(313526),o=t(753348);function i({children:e,hidden:n,className:t}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,r.A)(o.A.tabItem,t),hidden:n,children:e})}},685008(e,n,t){t.d(n,{A:()=>g});var s=t(886070),r=t(830758),o=t(313526),i=t(911212),a=t(274875),l=t(106632),c=t(189223),d=t(618264);function u({className:e,block:n,selectedValue:t,selectValue:r,tabValues:i}){let l=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.a_)(),u=e=>{let n=e.currentTarget,s=i[l.indexOf(n)].value;s!==t&&(c(n),r(s))},h=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{let t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{let t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1]}}n?.focus()};return(0,s.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":n},e),children:i.map(({value:e,label:n,attributes:r})=>(0,s.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{l.push(e)},onKeyDown:h,onClick:u,...r,className:(0,o.A)("tabs__item",d.A.tabItem,r?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function h({lazy:e,children:n,selectedValue:t}){let i=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){let e=i.find(e=>e.props.value===t);return e?(0,r.cloneElement)(e,{className:(0,o.A)("margin-top--md",e.props.className)}):null}return(0,s.jsx)("div",{className:"margin-top--md",children:i.map((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function p(e){let n=(0,l.u)(e);return(0,s.jsxs)("div",{className:(0,o.A)(i.G.tabs.container,"tabs-container",d.A.tabList),children:[(0,s.jsx)(u,{...n,...e}),(0,s.jsx)(h,{...n,...e})]})}function g(e){let n=(0,c.A)();return(0,s.jsx)(p,{...e,children:(0,l.v)(e.children)},String(n))}},106632(e,n,t){t.d(n,{u:()=>u,v:()=>c});var s=t(830758),r=t(325557),o=t(363717),i=t(125740),a=t(574229),l=t(270367);function c(e){return s.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,s.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function d({value:e,tabValues:n}){return n.some(n=>n.value===e)}function u(e){let n,{defaultValue:t,queryString:u=!1,groupId:h}=e,p=function(e){let{values:n,children:t}=e;return(0,s.useMemo)(()=>{let e=n??c(t).map(({props:{value:e,label:n,attributes:t,default:s}})=>({value:e,label:n,attributes:t,default:s})),s=(0,a.XI)(e,(e,n)=>e.value===n.value);if(s.length>0)throw Error(`Docusaurus error: Duplicate values "${s.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`);return e},[n,t])}(e),[g,f]=(0,s.useState)(()=>(function({defaultValue:e,tabValues:n}){if(0===n.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!d({value:e,tabValues:n}))throw Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}let t=n.find(e=>e.default)??n[0];if(!t)throw Error("Unexpected error: 0 tabValues");return t.value})({defaultValue:t,tabValues:p})),[m,j]=function({queryString:e=!1,groupId:n}){let t=(0,r.W6)(),o=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,i.aZ)(o),(0,s.useCallback)(e=>{if(!o)return;let n=new URLSearchParams(t.location.search);n.set(o,e),t.replace({...t.location,search:n.toString()})},[o,t])]}({queryString:u,groupId:h}),[v,_]=function({groupId:e}){let n=e?`docusaurus.tab.${e}`:null,[t,r]=(0,l.Dv)(n);return[t,(0,s.useCallback)(e=>{n&&r.set(e)},[n,r])]}({groupId:h}),y=d({value:n=m??v,tabValues:p})?n:null;return(0,o.A)(()=>{y&&f(y)},[y]),{selectedValue:g,selectValue:(0,s.useCallback)(e=>{if(!d({value:e,tabValues:p}))throw Error(`Can't select invalid tab value=${e}`);f(e),j(e),_(e)},[j,_,p]),tabValues:p}}},848193(e,n,t){t.d(n,{R:()=>i,x:()=>a});var s=t(830758);let r={},o=s.createContext(r);function i(e){let n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:n},e.children)}},659698(e){e.exports=JSON.parse('{"id":"docs/tutorials-coming-soon/advanced-plugin-concepts","title":"Advanced plugin concepts","description":"Learning advanced concepts for writing plugins.","source":"@site/versioned_docs/version-2.18/docs/tutorials-coming-soon/advanced-plugin-concepts.mdx","sourceDirName":"docs/tutorials-coming-soon","slug":"/docs/tutorials-coming-soon/advanced-plugin-concepts","permalink":"/2.18/docs/tutorials-coming-soon/advanced-plugin-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/pantsbuild/pants/edit/main/docs/docs/tutorials-coming-soon/advanced-plugin-concepts.mdx","tags":[],"version":"2.18","sidebarPosition":2,"frontMatter":{"title":"Advanced plugin concepts","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Create a new goal","permalink":"/2.18/docs/tutorials-coming-soon/create-a-new-goal"}}')}}]);